
firmware.elf:     file format elf32-msp430


Disassembly of section .text:

0000c000 <__init_stack>:
    c000:	31 40 00 04 	mov	#1024,	r1	;#0x0400

0000c004 <__low_level_init>:
    c004:	15 42 20 01 	mov	&0x0120,r5	
    c008:	75 f3       	and.b	#-1,	r5	;r3 As==11
    c00a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000c00e <__do_copy_data>:
    c00e:	3f 40 32 00 	mov	#50,	r15	;#0x0032
    c012:	0f 93       	tst	r15		
    c014:	07 24       	jz	$+16     	;abs 0xc024
    c016:	82 45 20 01 	mov	r5,	&0x0120	
    c01a:	2f 83       	decd	r15		
    c01c:	9f 4f 6c cb 	mov	-13460(r15),512(r15);0xcb6c(r15), 0x0200(r15)
    c020:	00 02 
    c022:	f9 23       	jnz	$-12     	;abs 0xc016

0000c024 <__do_clear_bss>:
    c024:	3f 40 2c 01 	mov	#300,	r15	;#0x012c
    c028:	0f 93       	tst	r15		
    c02a:	06 24       	jz	$+14     	;abs 0xc038
    c02c:	82 45 20 01 	mov	r5,	&0x0120	
    c030:	1f 83       	dec	r15		
    c032:	cf 43 32 02 	mov.b	#0,	562(r15);r3 As==00, 0x0232(r15)
    c036:	fa 23       	jnz	$-10     	;abs 0xc02c

0000c038 <main>:
    DCOCTL  = CALDCO_1MHZ;
}

int main(void)
{
	clock_init();
    c038:	b0 12 60 c0 	call	#0xc060	

	pin_reserve(PIN_1_1);
    c03c:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011
    c040:	b0 12 b4 c2 	call	#0xc2b4	
	pin_reserve(PIN_1_2);
    c044:	7f 40 12 00 	mov.b	#18,	r15	;#0x0012
    c048:	b0 12 b4 c2 	call	#0xc2b4	

	packet_handler_init();
    c04c:	b0 12 74 c0 	call	#0xc074	

	while (1) {
		packet_do_handle();
    c050:	b0 12 a2 c7 	call	#0xc7a2	
    c054:	fd 3f       	jmp	$-4      	;abs 0xc050

0000c056 <__stop_progExec__>:
    c056:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    c05a:	fd 3f       	jmp	$-4      	;abs 0xc056

0000c05c <__ctors_end>:
    c05c:	30 40 6a cb 	br	#0xcb6a	

0000c060 <clock_init>:

#include "rocketcore.h"

void clock_init(void)
{
	WDTCTL = WDTPW + WDTHOLD;
    c060:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c064:	20 01 
    BCSCTL1 = CALBC1_1MHZ;
    c066:	d2 42 ff 10 	mov.b	&0x10ff,&0x0057	
    c06a:	57 00 
    DCOCTL  = CALDCO_1MHZ;
    c06c:	d2 42 fe 10 	mov.b	&0x10fe,&0x0056	
    c070:	56 00 
}
    c072:	30 41       	ret			

0000c074 <packet_handler_init>:
 */
SERIAL_RB_Q stx_buf[RB_SIZE];
serial_rb stx;

void packet_handler_init()
{
    c074:	0b 12       	push	r11		
	serial_init(BAUDRATE);
    c076:	3f 40 80 25 	mov	#9600,	r15	;#0x2580
    c07a:	b0 12 d0 c1 	call	#0xc1d0	

    serial_rb_init(&srx, &(srx_buf[0]), RB_SIZE);
    c07e:	3b 40 40 00 	mov	#64,	r11	;#0x0040
    c082:	0d 4b       	mov	r11,	r13	
    c084:	3e 40 56 02 	mov	#598,	r14	;#0x0256
    c088:	3f 40 42 02 	mov	#578,	r15	;#0x0242
    c08c:	b0 12 6e c1 	call	#0xc16e	
    serial_rb_init(&stx, &(stx_buf[0]), RB_SIZE);
    c090:	0d 4b       	mov	r11,	r13	
    c092:	3e 40 96 02 	mov	#662,	r14	;#0x0296
    c096:	3f 40 4c 02 	mov	#588,	r15	;#0x024c
    c09a:	b0 12 6e c1 	call	#0xc16e	


    IE2 |= UCA0RXIE; 
    c09e:	d2 d3 01 00 	bis.b	#1,	&0x0001	;r3 As==01
	__bis_SR_register(GIE);
    c0a2:	32 d2       	eint			
}
    c0a4:	3b 41       	pop	r11		
    c0a6:	30 41       	ret			

0000c0a8 <packet_byte_to_sendq>:

void packet_byte_to_sendq(unsigned char pkt_byte) 
{
    c0a8:	0b 12       	push	r11		
    c0aa:	4b 4f       	mov.b	r15,	r11	
    c0ac:	01 3c       	jmp	$+4      	;abs 0xc0b0
	// wait until buffer empties 
	while(serial_rb_full(&stx)) {
		__asm__("nop");
    c0ae:	03 43       	nop			
}

void packet_byte_to_sendq(unsigned char pkt_byte) 
{
	// wait until buffer empties 
	while(serial_rb_full(&stx)) {
    c0b0:	3f 40 4c 02 	mov	#588,	r15	;#0x024c
    c0b4:	b0 12 50 c1 	call	#0xc150	
    c0b8:	0f 93       	tst	r15		
    c0ba:	f9 23       	jnz	$-12     	;abs 0xc0ae
		__asm__("nop");
	}

	serial_rb_write(&stx, pkt_byte);
    c0bc:	4e 4b       	mov.b	r11,	r14	
    c0be:	3f 40 4c 02 	mov	#588,	r15	;#0x024c
    c0c2:	b0 12 84 c1 	call	#0xc184	
	IE2 |= UCA0TXIE;
    c0c6:	e2 d3 01 00 	bis.b	#2,	&0x0001	;r3 As==10
}
    c0ca:	3b 41       	pop	r11		
    c0cc:	30 41       	ret			

0000c0ce <packet_byte_from_rcvq>:

unsigned char packet_byte_from_rcvq() 
{
    c0ce:	01 3c       	jmp	$+4      	;abs 0xc0d2
	// wait until data arrived in buffer
	while(serial_rb_empty(&srx)) {
		__asm__("nop");
    c0d0:	03 43       	nop			
}

unsigned char packet_byte_from_rcvq() 
{
	// wait until data arrived in buffer
	while(serial_rb_empty(&srx)) {
    c0d2:	3f 40 42 02 	mov	#578,	r15	;#0x0242
    c0d6:	b0 12 60 c1 	call	#0xc160	
    c0da:	0f 93       	tst	r15		
    c0dc:	f9 23       	jnz	$-12     	;abs 0xc0d0
		__asm__("nop");
	}

	return serial_rb_read(&srx);
    c0de:	3f 40 42 02 	mov	#578,	r15	;#0x0242
    c0e2:	b0 12 aa c1 	call	#0xc1aa	
}
    c0e6:	30 41       	ret			

0000c0e8 <USCI0RX_ISR>:

interrupt(USCIAB0RX_VECTOR) USCI0RX_ISR(void)
{
    c0e8:	0f 12       	push	r15		
    c0ea:	0e 12       	push	r14		
    c0ec:	0d 12       	push	r13		
    c0ee:	0c 12       	push	r12		
	if (!serial_rb_full(&srx)) {
    c0f0:	3f 40 42 02 	mov	#578,	r15	;#0x0242
    c0f4:	b0 12 50 c1 	call	#0xc150	
    c0f8:	0f 93       	tst	r15		
    c0fa:	06 20       	jnz	$+14     	;abs 0xc108
        serial_rb_write(&srx, UCA0RXBUF);
    c0fc:	5e 42 66 00 	mov.b	&0x0066,r14	
    c100:	3f 40 42 02 	mov	#578,	r15	;#0x0242
    c104:	b0 12 84 c1 	call	#0xc184	
	}
}
    c108:	3c 41       	pop	r12		
    c10a:	3d 41       	pop	r13		
    c10c:	3e 41       	pop	r14		
    c10e:	3f 41       	pop	r15		
    c110:	00 13       	reti			

0000c112 <USCI0TX_ISR>:

interrupt(USCIAB0TX_VECTOR) USCI0TX_ISR(void)
{
    c112:	0f 12       	push	r15		
    c114:	0e 12       	push	r14		
    c116:	0d 12       	push	r13		
    c118:	0c 12       	push	r12		
	if(!serial_rb_empty(&stx)) {
    c11a:	3f 40 4c 02 	mov	#588,	r15	;#0x024c
    c11e:	b0 12 60 c1 	call	#0xc160	
    c122:	0f 93       	tst	r15		
    c124:	07 20       	jnz	$+16     	;abs 0xc134
    	serial_send(serial_rb_read(&stx));
    c126:	3f 40 4c 02 	mov	#588,	r15	;#0x024c
    c12a:	b0 12 aa c1 	call	#0xc1aa	
    c12e:	b0 12 1c c2 	call	#0xc21c	
    c132:	03 3c       	jmp	$+8      	;abs 0xc13a
    }
    else {
		IE2 &= ~UCA0TXIE; 
    c134:	f2 f0 fd ff 	and.b	#-3,	&0x0001	;#0xfffd
    c138:	01 00 
    }
}
    c13a:	3c 41       	pop	r12		
    c13c:	3d 41       	pop	r13		
    c13e:	3e 41       	pop	r14		
    c140:	3f 41       	pop	r15		
    c142:	00 13       	reti			

0000c144 <serial_rb_free>:
#include "serial_rb.h"

unsigned short serial_rb_free(serial_rb *rb)
{
    return (rb->elements - rb->entries);
}
    c144:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    c148:	1e 8f 08 00 	sub	8(r15),	r14	;0x0008(r15)
    c14c:	0f 4e       	mov	r14,	r15	
    c14e:	30 41       	ret			

0000c150 <serial_rb_full>:

int serial_rb_full(serial_rb *rb)
{
    return (rb->elements == rb->entries);
    c150:	1e 43       	mov	#1,	r14	;r3 As==01
    c152:	9f 9f 08 00 	cmp	8(r15),	6(r15)	;0x0008(r15), 0x0006(r15)
    c156:	06 00 
    c158:	01 24       	jz	$+4      	;abs 0xc15c
    c15a:	0e 43       	clr	r14		
}
    c15c:	0f 4e       	mov	r14,	r15	
    c15e:	30 41       	ret			

0000c160 <serial_rb_empty>:

int serial_rb_empty(serial_rb *rb)
{
    return (rb->entries == 0);
    c160:	1e 43       	mov	#1,	r14	;r3 As==01
    c162:	8f 93 08 00 	tst	8(r15)		;0x0008(r15)
    c166:	01 24       	jz	$+4      	;abs 0xc16a
    c168:	0e 43       	clr	r14		
}
    c16a:	0f 4e       	mov	r14,	r15	
    c16c:	30 41       	ret			

0000c16e <serial_rb_init>:

void serial_rb_init(serial_rb *rb, SERIAL_RB_Q *buffer, unsigned short elements)
{
    rb->buffer      = buffer;
    c16e:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    rb->read        = &(rb->buffer[0]);
    c172:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
    rb->write       = &(rb->buffer[0]);
    c176:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    rb->elements    = elements;
    c17a:	8f 4d 06 00 	mov	r13,	6(r15)	;0x0006(r15)
    rb->entries     = 0;
    c17e:	8f 43 08 00 	mov	#0,	8(r15)	;r3 As==00, 0x0008(r15)
}
    c182:	30 41       	ret			

0000c184 <serial_rb_write>:

void serial_rb_write(serial_rb *rb, SERIAL_RB_Q element)
{
  rb->entries++;
    c184:	9f 53 08 00 	inc	8(r15)		;0x0008(r15)

  if (rb->write > &(rb->buffer[rb->elements - 1])) {
    c188:	1d 4f 06 00 	mov	6(r15),	r13	;0x0006(r15)
    c18c:	3d 53       	add	#-1,	r13	;r3 As==11
    c18e:	2d 5f       	add	@r15,	r13	
    c190:	1d 9f 04 00 	cmp	4(r15),	r13	;0x0004(r15)
    c194:	02 2c       	jc	$+6      	;abs 0xc19a
      rb->write = &(rb->buffer[0]);
    c196:	af 4f 04 00 	mov	@r15,	4(r15)	;0x0004(r15)
  }

  *(rb->write++) = element;
    c19a:	1d 4f 04 00 	mov	4(r15),	r13	;0x0004(r15)
    c19e:	cd 4e 00 00 	mov.b	r14,	0(r13)	;0x0000(r13)
    c1a2:	1d 53       	inc	r13		
    c1a4:	8f 4d 04 00 	mov	r13,	4(r15)	;0x0004(r15)
}
    c1a8:	30 41       	ret			

0000c1aa <serial_rb_read>:

SERIAL_RB_Q serial_rb_read(serial_rb *rb)
{
  rb->entries--;
    c1aa:	bf 53 08 00 	add	#-1,	8(r15)	;r3 As==11, 0x0008(r15)

  if (rb->read > &(rb->buffer[rb->elements - 1])) {
    c1ae:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    c1b2:	3e 53       	add	#-1,	r14	;r3 As==11
    c1b4:	2e 5f       	add	@r15,	r14	
    c1b6:	1e 9f 02 00 	cmp	2(r15),	r14	;0x0002(r15)
    c1ba:	02 2c       	jc	$+6      	;abs 0xc1c0
      rb->read = &(rb->buffer[0]);
    c1bc:	af 4f 02 00 	mov	@r15,	2(r15)	;0x0002(r15)
  }

  return *(rb->read++);
    c1c0:	1d 4f 02 00 	mov	2(r15),	r13	;0x0002(r15)
    c1c4:	6e 4d       	mov.b	@r13,	r14	
    c1c6:	1d 53       	inc	r13		
    c1c8:	8f 4d 02 00 	mov	r13,	2(r15)	;0x0002(r15)
}
    c1cc:	4f 4e       	mov.b	r14,	r15	
    c1ce:	30 41       	ret			

0000c1d0 <serial_init>:
 * TXD pin
 */
#define UART_TXD   		BIT2	

void serial_init(unsigned int baudrate)
{
    c1d0:	0b 12       	push	r11		
    c1d2:	0a 12       	push	r10		
    c1d4:	09 12       	push	r9		
    c1d6:	08 12       	push	r8		
    c1d8:	07 12       	push	r7		
	P1SEL    |= UART_RXD + UART_TXD;                       
    c1da:	f2 d0 06 00 	bis.b	#6,	&0x0026	;#0x0006
    c1de:	26 00 
  	P1SEL2   |= UART_RXD + UART_TXD;                       
    c1e0:	f2 d0 06 00 	bis.b	#6,	&0x0041	;#0x0006
    c1e4:	41 00 
  	UCA0CTL1 |= UCSSEL_2;                   // SMCLK
    c1e6:	f2 d0 80 ff 	bis.b	#-128,	&0x0061	;#0xff80
    c1ea:	61 00 

	unsigned char br = (unsigned char)(1000000 / (long)baudrate);
    c1ec:	07 43       	clr	r7		
    c1ee:	3c 40 40 42 	mov	#16960,	r12	;#0x4240
    c1f2:	3d 40 0f 00 	mov	#15,	r13	;#0x000f
    c1f6:	0a 4f       	mov	r15,	r10	
    c1f8:	0b 47       	mov	r7,	r11	
    c1fa:	b0 12 f6 ca 	call	#0xcaf6	

  	UCA0BR0  = br;                          // 1MHz / baudrate 
    c1fe:	c2 4c 62 00 	mov.b	r12,	&0x0062	
  	UCA0BR1  = 0;                           // 
    c202:	c2 47 63 00 	mov.b	r7,	&0x0063	
  	UCA0MCTL = UCBRS0;                      // Modulation UCBRSx = 1
    c206:	e2 43 64 00 	mov.b	#2,	&0x0064	;r3 As==10
  	UCA0CTL1 &= ~UCSWRST;                   // Initialize USCI state machine
    c20a:	f2 f0 fe ff 	and.b	#-2,	&0x0061	;#0xfffe
    c20e:	61 00 
}
    c210:	37 41       	pop	r7		
    c212:	38 41       	pop	r8		
    c214:	39 41       	pop	r9		
    c216:	3a 41       	pop	r10		
    c218:	3b 41       	pop	r11		
    c21a:	30 41       	ret			

0000c21c <serial_send>:

void serial_send(unsigned char data)
{
  	UCA0TXBUF = data;                 		
    c21c:	c2 4f 67 00 	mov.b	r15,	&0x0067	
}
    c220:	30 41       	ret			

0000c222 <serial_send_blocking>:

void serial_send_blocking(unsigned char data)
{
	while (!(IFG2&UCA0TXIFG));              // USCI_A0 TX buffer ready?
    c222:	5e 42 03 00 	mov.b	&0x0003,r14	
    c226:	2e f3       	and	#2,	r14	;r3 As==10
    c228:	fc 27       	jz	$-6      	;abs 0xc222
  	UCA0TXBUF = data;                  
    c22a:	c2 4f 67 00 	mov.b	r15,	&0x0067	
}
    c22e:	30 41       	ret			

0000c230 <serial_recv>:

unsigned char serial_recv()
{
	return UCA0RXBUF;
}
    c230:	5f 42 66 00 	mov.b	&0x0066,r15	
    c234:	30 41       	ret			

0000c236 <serial_recv_blocking>:

unsigned char serial_recv_blocking()
{
    while (!(IFG2&UCA0RXIFG));         		// USCI_A0 RX buffer ready?
    c236:	5f 42 03 00 	mov.b	&0x0003,r15	
    c23a:	1f f3       	and	#1,	r15	;r3 As==01
    c23c:	fc 27       	jz	$-6      	;abs 0xc236
	return UCA0RXBUF;
}
    c23e:	5f 42 66 00 	mov.b	&0x0066,r15	
    c242:	30 41       	ret			

0000c244 <pin2port>:
	PIN_FUNCTION_INPUT_FLOAT,			// P2.7
};

int pin2port(unsigned char pin) 
{
	int port = (0xF0 & pin) >> 4;
    c244:	12 c3       	clrc			
    c246:	4f 10       	rrc.b	r15		
    c248:	4f 11       	rra.b	r15		
    c24a:	4f 11       	rra.b	r15		
    c24c:	4f 11       	rra.b	r15		
    c24e:	4f 4f       	mov.b	r15,	r15	

	if(port >= 1 && port <= 2) { 
    c250:	0e 4f       	mov	r15,	r14	
    c252:	3e 53       	add	#-1,	r14	;r3 As==11
    c254:	2e 93       	cmp	#2,	r14	;r3 As==10
    c256:	02 28       	jnc	$+6      	;abs 0xc25c
		return port;
	}

	return PIN_STAT_ERR_INVALPORT;
    c258:	3f 40 fe ff 	mov	#-2,	r15	;#0xfffe
}
    c25c:	30 41       	ret			

0000c25e <pin2bit>:
{
	int bit_num = (0x0F & pin);
	int bit 	=  0x01 << bit_num;

	// RX/TX of uart1 are reserved, bits 0-7 are allowed 
	if(pin == PIN_1_1 || pin == PIN_1_2 || bit_num > 7) {
    c25e:	4e 4f       	mov.b	r15,	r14	
    c260:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef
    c264:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    c266:	0c 28       	jnc	$+26     	;abs 0xc280
	return PIN_STAT_ERR_INVALPORT;
}

int pin2bit(unsigned char pin) 
{
	int bit_num = (0x0F & pin);
    c268:	0e 4f       	mov	r15,	r14	
    c26a:	3e f0 0f 00 	and	#15,	r14	;#0x000f
	int bit 	=  0x01 << bit_num;

	// RX/TX of uart1 are reserved, bits 0-7 are allowed 
	if(pin == PIN_1_1 || pin == PIN_1_2 || bit_num > 7) {
    c26e:	3e 92       	cmp	#8,	r14	;r2 As==11
    c270:	0a 34       	jge	$+22     	;abs 0xc286
}

int pin2bit(unsigned char pin) 
{
	int bit_num = (0x0F & pin);
	int bit 	=  0x01 << bit_num;
    c272:	1f 43       	mov	#1,	r15	;r3 As==01
    c274:	0e 93       	tst	r14		
    c276:	03 24       	jz	$+8      	;abs 0xc27e
    c278:	0f 5f       	rla	r15		
    c27a:	1e 83       	dec	r14		
    c27c:	fd 23       	jnz	$-4      	;abs 0xc278
	// RX/TX of uart1 are reserved, bits 0-7 are allowed 
	if(pin == PIN_1_1 || pin == PIN_1_2 || bit_num > 7) {
		return PIN_STAT_ERR_INVALPIN;
	}

	return bit;
    c27e:	30 41       	ret			
	int bit_num = (0x0F & pin);
	int bit 	=  0x01 << bit_num;

	// RX/TX of uart1 are reserved, bits 0-7 are allowed 
	if(pin == PIN_1_1 || pin == PIN_1_2 || bit_num > 7) {
		return PIN_STAT_ERR_INVALPIN;
    c280:	3f 40 fd ff 	mov	#-3,	r15	;#0xfffd
    c284:	30 41       	ret			
    c286:	3f 40 fd ff 	mov	#-3,	r15	;#0xfffd
	}

	return bit;
}
    c28a:	30 41       	ret			

0000c28c <pin_set_curr_func>:

void pin_set_curr_func(unsigned char pin, unsigned char func) 
{
	int port    = (0xF0 & pin) >> 4;
    c28c:	4d 4f       	mov.b	r15,	r13	
    c28e:	12 c3       	clrc			
    c290:	4d 10       	rrc.b	r13		
    c292:	4d 11       	rra.b	r13		
    c294:	4d 11       	rra.b	r13		
    c296:	4d 11       	rra.b	r13		
    c298:	4d 4d       	mov.b	r13,	r13	
	int bit_num = (0x0F & pin);
	int idx  	= (port - 1) * 8 + bit_num;
    c29a:	3d 53       	add	#-1,	r13	;r3 As==11
    c29c:	0d 5d       	rla	r13		
    c29e:	0d 5d       	rla	r13		
    c2a0:	0d 5d       	rla	r13		
}

void pin_set_curr_func(unsigned char pin, unsigned char func) 
{
	int port    = (0xF0 & pin) >> 4;
	int bit_num = (0x0F & pin);
    c2a2:	3f f0 0f 00 	and	#15,	r15	;#0x000f
	int idx  	= (port - 1) * 8 + bit_num;
    c2a6:	0d 5f       	add	r15,	r13	

	if((unsigned int)idx > sizeof(pin_curr_func)) {
    c2a8:	3d 90 11 00 	cmp	#17,	r13	;#0x0011
    c2ac:	02 2c       	jc	$+6      	;abs 0xc2b2
		return;
	}

	pin_curr_func[idx] = func;
    c2ae:	cd 4e 32 02 	mov.b	r14,	562(r13);0x0232(r13)
    c2b2:	30 41       	ret			

0000c2b4 <pin_reserve>:
}

void pin_reserve(unsigned char pin) 
{
	pin_set_curr_func(pin, 0);	
    c2b4:	4e 43       	clr.b	r14		
    c2b6:	b0 12 8c c2 	call	#0xc28c	
}
    c2ba:	30 41       	ret			

0000c2bc <pin_function>:

unsigned char pin_function(unsigned char pin) 
{
	int port    = (0xF0 & pin) >> 4;
    c2bc:	4e 4f       	mov.b	r15,	r14	
    c2be:	12 c3       	clrc			
    c2c0:	4e 10       	rrc.b	r14		
    c2c2:	4e 11       	rra.b	r14		
    c2c4:	4e 11       	rra.b	r14		
    c2c6:	4e 11       	rra.b	r14		
    c2c8:	4e 4e       	mov.b	r14,	r14	
	int bit_num = (0x0F & pin);
	int idx  	= (port - 1) * 8 + bit_num;
    c2ca:	3e 53       	add	#-1,	r14	;r3 As==11
    c2cc:	0e 5e       	rla	r14		
    c2ce:	0e 5e       	rla	r14		
    c2d0:	0e 5e       	rla	r14		
}

unsigned char pin_function(unsigned char pin) 
{
	int port    = (0xF0 & pin) >> 4;
	int bit_num = (0x0F & pin);
    c2d2:	3f f0 0f 00 	and	#15,	r15	;#0x000f
	int idx  	= (port - 1) * 8 + bit_num;
    c2d6:	0e 5f       	add	r15,	r14	

	if((unsigned int)idx > sizeof(pin_curr_func)) {
    c2d8:	3e 90 11 00 	cmp	#17,	r14	;#0x0011
    c2dc:	03 2c       	jc	$+8      	;abs 0xc2e4
		return 0;
	}

	return pin_curr_func[idx];
    c2de:	5f 4e 32 02 	mov.b	562(r14),r15	;0x0232(r14)
    c2e2:	30 41       	ret			
	int port    = (0xF0 & pin) >> 4;
	int bit_num = (0x0F & pin);
	int idx  	= (port - 1) * 8 + bit_num;

	if((unsigned int)idx > sizeof(pin_curr_func)) {
		return 0;
    c2e4:	4f 43       	clr.b	r15		
	}

	return pin_curr_func[idx];
}
    c2e6:	30 41       	ret			

0000c2e8 <pin_with_function>:

unsigned char pin_with_function(unsigned char pin, unsigned char function) 
{
	int port    = (0xF0 & pin) >> 4;
	int bit_num = (0x0F & pin);
	int idx  	= (pin == 0 ? 0 : (port - 1) * 8 + bit_num + 1) ;
    c2e8:	4f 93       	tst.b	r15		
    c2ea:	10 24       	jz	$+34     	;abs 0xc30c
}

unsigned char pin_with_function(unsigned char pin, unsigned char function) 
{
	int port    = (0xF0 & pin) >> 4;
	int bit_num = (0x0F & pin);
    c2ec:	0d 4f       	mov	r15,	r13	
    c2ee:	3d f0 0f 00 	and	#15,	r13	;#0x000f
	int idx  	= (pin == 0 ? 0 : (port - 1) * 8 + bit_num + 1) ;
    c2f2:	1d 53       	inc	r13		
	return pin_curr_func[idx];
}

unsigned char pin_with_function(unsigned char pin, unsigned char function) 
{
	int port    = (0xF0 & pin) >> 4;
    c2f4:	12 c3       	clrc			
    c2f6:	4f 10       	rrc.b	r15		
    c2f8:	4f 11       	rra.b	r15		
    c2fa:	4f 11       	rra.b	r15		
    c2fc:	4f 11       	rra.b	r15		
    c2fe:	4f 4f       	mov.b	r15,	r15	
	int bit_num = (0x0F & pin);
	int idx  	= (pin == 0 ? 0 : (port - 1) * 8 + bit_num + 1) ;
    c300:	3f 53       	add	#-1,	r15	;r3 As==11
    c302:	0f 5f       	rla	r15		
    c304:	0f 5f       	rla	r15		
    c306:	0f 5f       	rla	r15		
    c308:	0d 5f       	add	r15,	r13	
    c30a:	01 3c       	jmp	$+4      	;abs 0xc30e
    c30c:	0d 43       	clr	r13		
	int i;

	for(i = idx + 1; (unsigned int)i < sizeof(pin_curr_func); i++) {
    c30e:	1d 53       	inc	r13		
    c310:	3f 40 0f 00 	mov	#15,	r15	;#0x000f
    c314:	11 3c       	jmp	$+36     	;abs 0xc338
		if(pin_curr_func[i] == function) {
    c316:	cd 9e 32 02 	cmp.b	r14,	562(r13);0x0232(r13)
    c31a:	0d 20       	jnz	$+28     	;abs 0xc336
			return (((i / 8 + 1) << 4) + (i % 8));
    c31c:	0f 4d       	mov	r13,	r15	
    c31e:	0f 11       	rra	r15		
    c320:	0f 11       	rra	r15		
    c322:	0f 11       	rra	r15		
    c324:	5f 53       	inc.b	r15		
    c326:	4f 5f       	rla.b	r15		
    c328:	4f 5f       	rla.b	r15		
    c32a:	4f 5f       	rla.b	r15		
    c32c:	4f 5f       	rla.b	r15		
    c32e:	3d f0 07 00 	and	#7,	r13	;#0x0007
    c332:	4f 5d       	add.b	r13,	r15	
    c334:	30 41       	ret			
	int port    = (0xF0 & pin) >> 4;
	int bit_num = (0x0F & pin);
	int idx  	= (pin == 0 ? 0 : (port - 1) * 8 + bit_num + 1) ;
	int i;

	for(i = idx + 1; (unsigned int)i < sizeof(pin_curr_func); i++) {
    c336:	1d 53       	inc	r13		
    c338:	0f 9d       	cmp	r13,	r15	
    c33a:	ed 2f       	jc	$-36     	;abs 0xc316
		if(pin_curr_func[i] == function) {
			return (((i / 8 + 1) << 4) + (i % 8));
		}
	}

	return 0;
    c33c:	4f 43       	clr.b	r15		
}
    c33e:	30 41       	ret			

0000c340 <pin_capabilities>:
int pin_capabilities(unsigned char pin) 
{
	int caps = 0;

	// PIN_CAP_INPUT
	if( pin == PIN_1_0 || pin == PIN_1_3 || pin == PIN_1_4 ||
    c340:	7f 90 10 00 	cmp.b	#16,	r15	;#0x0010
    c344:	4a 24       	jz	$+150    	;abs 0xc3da
    c346:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    c34a:	8a 24       	jz	$+278    	;abs 0xc460
    c34c:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    c350:	44 24       	jz	$+138    	;abs 0xc3da
    c352:	7f 90 15 00 	cmp.b	#21,	r15	;#0x0015
    c356:	1e 24       	jz	$+62     	;abs 0xc394
		pin == PIN_1_5 || pin == PIN_1_6 || pin == PIN_1_7 ||	 
    c358:	7f 90 16 00 	cmp.b	#22,	r15	;#0x0016
    c35c:	1b 24       	jz	$+56     	;abs 0xc394
    c35e:	7f 90 17 00 	cmp.b	#23,	r15	;#0x0017
    c362:	18 24       	jz	$+50     	;abs 0xc394
    c364:	7f 90 20 00 	cmp.b	#32,	r15	;#0x0020
    c368:	15 24       	jz	$+44     	;abs 0xc394
	    pin == PIN_2_0 || pin == PIN_2_1 || pin == PIN_2_2 ||
    c36a:	7f 90 21 00 	cmp.b	#33,	r15	;#0x0021
    c36e:	12 24       	jz	$+38     	;abs 0xc394
    c370:	7f 90 22 00 	cmp.b	#34,	r15	;#0x0022
    c374:	0f 24       	jz	$+32     	;abs 0xc394
    c376:	7f 90 23 00 	cmp.b	#35,	r15	;#0x0023
    c37a:	0c 24       	jz	$+26     	;abs 0xc394
        pin == PIN_2_3 || pin == PIN_2_4 || pin == PIN_2_5 || 
    c37c:	7f 90 24 00 	cmp.b	#36,	r15	;#0x0024
    c380:	09 24       	jz	$+20     	;abs 0xc394
    c382:	7f 90 25 00 	cmp.b	#37,	r15	;#0x0025
    c386:	06 24       	jz	$+14     	;abs 0xc394
    c388:	7f 90 26 00 	cmp.b	#38,	r15	;#0x0026
    c38c:	03 24       	jz	$+8      	;abs 0xc394
		pin == PIN_2_6 || pin == PIN_2_7) {
    c38e:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    c392:	68 20       	jnz	$+210    	;abs 0xc464
	
		caps |= PIN_CAP_INPUT;
	} 

	// PIN_CAP_INPUT_RE
	if( pin == PIN_1_0 || pin == PIN_1_4 ||
    c394:	7f 90 15 00 	cmp.b	#21,	r15	;#0x0015
    c398:	20 24       	jz	$+66     	;abs 0xc3da
    c39a:	1e 43       	mov	#1,	r14	;r3 As==01
		pin == PIN_1_5 || pin == PIN_1_6 || pin == PIN_1_7 ||	 
    c39c:	7f 90 16 00 	cmp.b	#22,	r15	;#0x0016
    c3a0:	1d 24       	jz	$+60     	;abs 0xc3dc
    c3a2:	7f 90 17 00 	cmp.b	#23,	r15	;#0x0017
    c3a6:	1a 24       	jz	$+54     	;abs 0xc3dc
    c3a8:	7f 90 20 00 	cmp.b	#32,	r15	;#0x0020
    c3ac:	17 24       	jz	$+48     	;abs 0xc3dc
	    pin == PIN_2_0 || pin == PIN_2_1 || pin == PIN_2_2 ||
    c3ae:	7f 90 21 00 	cmp.b	#33,	r15	;#0x0021
    c3b2:	14 24       	jz	$+42     	;abs 0xc3dc
    c3b4:	7f 90 22 00 	cmp.b	#34,	r15	;#0x0022
    c3b8:	11 24       	jz	$+36     	;abs 0xc3dc
    c3ba:	7f 90 23 00 	cmp.b	#35,	r15	;#0x0023
    c3be:	0e 24       	jz	$+30     	;abs 0xc3dc
        pin == PIN_2_3 || pin == PIN_2_4 || pin == PIN_2_5 || 
    c3c0:	7f 90 24 00 	cmp.b	#36,	r15	;#0x0024
    c3c4:	0b 24       	jz	$+24     	;abs 0xc3dc
    c3c6:	7f 90 25 00 	cmp.b	#37,	r15	;#0x0025
    c3ca:	08 24       	jz	$+18     	;abs 0xc3dc
    c3cc:	7f 90 26 00 	cmp.b	#38,	r15	;#0x0026
    c3d0:	05 24       	jz	$+12     	;abs 0xc3dc
		pin == PIN_2_6 || pin == PIN_2_7) {
    c3d2:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    c3d6:	06 20       	jnz	$+14     	;abs 0xc3e4
    c3d8:	01 3c       	jmp	$+4      	;abs 0xc3dc
	
		caps |= PIN_CAP_INPUT;
	} 

	// PIN_CAP_INPUT_RE
	if( pin == PIN_1_0 || pin == PIN_1_4 ||
    c3da:	1e 43       	mov	#1,	r14	;r3 As==01
		pin == PIN_1_5 || pin == PIN_1_6 || pin == PIN_1_7 ||	 
	    pin == PIN_2_0 || pin == PIN_2_1 || pin == PIN_2_2 ||
        pin == PIN_2_3 || pin == PIN_2_4 || pin == PIN_2_5 || 
		pin == PIN_2_6 || pin == PIN_2_7) {
	
		caps |= PIN_CAP_INPUT_RE;
    c3dc:	2e d3       	bis	#2,	r14	;r3 As==10

	// PIN_CAP_OUTPUT
	// PIN_CAP_PWM
	// PIN_CAP_UARTRX
	// PIN_CAP_UARTTX
	if( pin == PIN_1_0 || pin == PIN_1_3 || pin == PIN_1_4 ||
    c3de:	7f 90 10 00 	cmp.b	#16,	r15	;#0x0010
    c3e2:	27 24       	jz	$+80     	;abs 0xc432
    c3e4:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    c3e8:	24 24       	jz	$+74     	;abs 0xc432
    c3ea:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    c3ee:	21 24       	jz	$+68     	;abs 0xc432
    c3f0:	7f 90 15 00 	cmp.b	#21,	r15	;#0x0015
    c3f4:	1e 24       	jz	$+62     	;abs 0xc432
		pin == PIN_1_5 || pin == PIN_1_6 || pin == PIN_1_7 ||	 
    c3f6:	7f 90 16 00 	cmp.b	#22,	r15	;#0x0016
    c3fa:	1b 24       	jz	$+56     	;abs 0xc432
    c3fc:	7f 90 17 00 	cmp.b	#23,	r15	;#0x0017
    c400:	18 24       	jz	$+50     	;abs 0xc432
    c402:	7f 90 20 00 	cmp.b	#32,	r15	;#0x0020
    c406:	15 24       	jz	$+44     	;abs 0xc432
	    pin == PIN_2_0 || pin == PIN_2_1 || pin == PIN_2_2 ||
    c408:	7f 90 21 00 	cmp.b	#33,	r15	;#0x0021
    c40c:	12 24       	jz	$+38     	;abs 0xc432
    c40e:	7f 90 22 00 	cmp.b	#34,	r15	;#0x0022
    c412:	0f 24       	jz	$+32     	;abs 0xc432
    c414:	7f 90 23 00 	cmp.b	#35,	r15	;#0x0023
    c418:	0c 24       	jz	$+26     	;abs 0xc432
        pin == PIN_2_3 || pin == PIN_2_4 || pin == PIN_2_5 || 
    c41a:	7f 90 24 00 	cmp.b	#36,	r15	;#0x0024
    c41e:	09 24       	jz	$+20     	;abs 0xc432
    c420:	7f 90 25 00 	cmp.b	#37,	r15	;#0x0025
    c424:	06 24       	jz	$+14     	;abs 0xc432
    c426:	7f 90 26 00 	cmp.b	#38,	r15	;#0x0026
    c42a:	03 24       	jz	$+8      	;abs 0xc432
		pin == PIN_2_6 || pin == PIN_2_7) {
    c42c:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    c430:	0b 20       	jnz	$+24     	;abs 0xc448
	
		caps |= PIN_CAP_OUTPUT + PIN_CAP_PWM + PIN_CAP_UARTTX + PIN_CAP_UARTRX;
    c432:	3e d0 74 00 	bis	#116,	r14	;#0x0074
	} 

	// PIN_CAP_ANALOG_IN
	if( pin == PIN_1_0 || pin == PIN_1_3 || pin == PIN_1_4 ||
    c436:	7f 90 10 00 	cmp.b	#16,	r15	;#0x0010
    c43a:	0f 24       	jz	$+32     	;abs 0xc45a
    c43c:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    c440:	0c 24       	jz	$+26     	;abs 0xc45a
    c442:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    c446:	09 24       	jz	$+20     	;abs 0xc45a
    c448:	7f 90 15 00 	cmp.b	#21,	r15	;#0x0015
    c44c:	06 24       	jz	$+14     	;abs 0xc45a
		pin == PIN_1_5 || pin == PIN_1_6 || pin == PIN_1_7) {
    c44e:	7f 90 16 00 	cmp.b	#22,	r15	;#0x0016
    c452:	03 24       	jz	$+8      	;abs 0xc45a
    c454:	7f 90 17 00 	cmp.b	#23,	r15	;#0x0017
    c458:	01 20       	jnz	$+4      	;abs 0xc45c
	
		caps |= PIN_CAP_ANALOG_IN;
    c45a:	3e d2       	bis	#8,	r14	;r2 As==11
	} 

	return caps;
}
    c45c:	0f 4e       	mov	r14,	r15	
    c45e:	30 41       	ret			
int pin_capabilities(unsigned char pin) 
{
	int caps = 0;

	// PIN_CAP_INPUT
	if( pin == PIN_1_0 || pin == PIN_1_3 || pin == PIN_1_4 ||
    c460:	1e 43       	mov	#1,	r14	;r3 As==01
    c462:	e7 3f       	jmp	$-48     	;abs 0xc432
	return 0;
}

int pin_capabilities(unsigned char pin) 
{
	int caps = 0;
    c464:	0e 43       	clr	r14		
    c466:	9a 3f       	jmp	$-202    	;abs 0xc39c

0000c468 <pin_has_capabilities>:

	return caps;
}

int pin_has_capabilities(unsigned char pin, int capabilities) 
{
    c468:	0b 12       	push	r11		
    c46a:	0b 4e       	mov	r14,	r11	
	return ((pin_capabilities(pin) & capabilities) == capabilities ? 1 : 0);
    c46c:	b0 12 40 c3 	call	#0xc340	
    c470:	0e 4f       	mov	r15,	r14	
    c472:	0e fb       	and	r11,	r14	
    c474:	1f 43       	mov	#1,	r15	;r3 As==01
    c476:	0e 9b       	cmp	r11,	r14	
    c478:	01 24       	jz	$+4      	;abs 0xc47c
    c47a:	0f 43       	clr	r15		
}
    c47c:	3b 41       	pop	r11		
    c47e:	30 41       	ret			

0000c480 <pin_setup>:

int pin_setup(unsigned char pin, unsigned char function)
{
    c480:	0b 12       	push	r11		
    c482:	0a 12       	push	r10		
    c484:	09 12       	push	r9		
    c486:	08 12       	push	r8		
    c488:	49 4f       	mov.b	r15,	r9	
    c48a:	48 4e       	mov.b	r14,	r8	
	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
    c48c:	b0 12 44 c2 	call	#0xc244	
    c490:	0b 4f       	mov	r15,	r11	
    c492:	0f 93       	tst	r15		
    c494:	ae 38       	jl	$+350    	;abs 0xc5f2
	if((bit  = pin2bit(pin))  < 0) return bit;
    c496:	4f 49       	mov.b	r9,	r15	
    c498:	b0 12 5e c2 	call	#0xc25e	
    c49c:	0a 4f       	mov	r15,	r10	
    c49e:	0f 93       	tst	r15		
    c4a0:	a3 38       	jl	$+328    	;abs 0xc5e8

	// see if PIN is already configured for the given function
	if(pin_function(pin) == function) { 
    c4a2:	4f 49       	mov.b	r9,	r15	
    c4a4:	b0 12 bc c2 	call	#0xc2bc	
    c4a8:	4f 98       	cmp.b	r8,	r15	
    c4aa:	a0 24       	jz	$+322    	;abs 0xc5ec
		return PIN_STAT_OK;
	}

	switch(function) {
    c4ac:	78 92       	cmp.b	#8,	r8	;r2 As==11
    c4ae:	a0 2c       	jc	$+322    	;abs 0xc5f0
    c4b0:	4f 48       	mov.b	r8,	r15	
    c4b2:	0f 5f       	rla	r15		
    c4b4:	10 4f b8 c4 	br	-15176(r15)	;0xc4b8(r15)
    c4b8:	c8 c4 ec c4 	bic.b	r4,	-15124(r8);0xc4ec(r8)
    c4bc:	14 c5 4c c5 	bic	-15028(r5),r4	;0xc54c(r5)
    c4c0:	80 c5 9e c5 	bic	r5,	0xc59e	;PC rel. 0x08a62
    c4c4:	ae c5 c2 c5 	bic	@r5,	-14910(r14);0xc5c2(r14)
	case PIN_FUNCTION_INPUT_FLOAT:
		if(!pin_has_capabilities(pin, PIN_CAP_INPUT)) {
    c4c8:	1e 43       	mov	#1,	r14	;r3 As==01
    c4ca:	4f 49       	mov.b	r9,	r15	
    c4cc:	b0 12 68 c4 	call	#0xc468	
    c4d0:	0f 93       	tst	r15		
    c4d2:	8e 24       	jz	$+286    	;abs 0xc5f0
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		if(port == 1) {
    c4d4:	1b 93       	cmp	#1,	r11	;r3 As==01
    c4d6:	04 20       	jnz	$+10     	;abs 0xc4e0
			P1DIR &= ~bit;					// make sure to clear OUT flag for the pin                 
    c4d8:	7a e3       	xor.b	#-1,	r10	;r3 As==11
    c4da:	c2 fa 22 00 	and.b	r10,	&0x0022	
    c4de:	43 3c       	jmp	$+136    	;abs 0xc566
			P1REN &= ~bit; 	                // disable pull-up/down 
		}
		else if(port == 2) {
    c4e0:	2b 93       	cmp	#2,	r11	;r3 As==10
    c4e2:	7d 20       	jnz	$+252    	;abs 0xc5de
			P2DIR &= ~bit;					// make sure to clear OUT flag for the pin                 
    c4e4:	7a e3       	xor.b	#-1,	r10	;r3 As==11
    c4e6:	c2 fa 2a 00 	and.b	r10,	&0x002a	
    c4ea:	47 3c       	jmp	$+144    	;abs 0xc57a
			P2REN &= ~bit; 	                // disable pull-up/down 
		}
		break;
	case PIN_FUNCTION_INPUT_PULLUP:
		if(!pin_has_capabilities(pin, PIN_CAP_INPUT_RE)) { 
    c4ec:	2e 43       	mov	#2,	r14	;r3 As==10
    c4ee:	4f 49       	mov.b	r9,	r15	
    c4f0:	b0 12 68 c4 	call	#0xc468	
    c4f4:	0f 93       	tst	r15		
    c4f6:	7c 24       	jz	$+250    	;abs 0xc5f0
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		if(port == 1) {
    c4f8:	1b 93       	cmp	#1,	r11	;r3 As==01
    c4fa:	05 20       	jnz	$+12     	;abs 0xc506
			P1DIR &= ~bit;					// make sure to clear OUT flag for the pin                 
    c4fc:	c2 ca 22 00 	bic.b	r10,	&0x0022	
  			P1OUT |=  bit;					// setting out to HIGH enables pull-up                     
    c500:	c2 da 21 00 	bis.b	r10,	&0x0021	
    c504:	15 3c       	jmp	$+44     	;abs 0xc530
			P1REN |=  bit; 	                // enable pull-up/down 
		}
		else if(port == 2) {
    c506:	2b 93       	cmp	#2,	r11	;r3 As==10
    c508:	6a 20       	jnz	$+214    	;abs 0xc5de
			P2DIR &= ~bit;					// make sure to clear OUT flag for the pin                 
    c50a:	c2 ca 2a 00 	bic.b	r10,	&0x002a	
  			P2OUT |=  bit;					// setting out to HIGH enables pull-up                     
    c50e:	c2 da 29 00 	bis.b	r10,	&0x0029	
    c512:	19 3c       	jmp	$+52     	;abs 0xc546
			P2REN |=  bit; 	                // enable pull-up/down 
		}
		break;
	case PIN_FUNCTION_INPUT_PULLDOWN:
		if(!pin_has_capabilities(pin, PIN_CAP_INPUT_RE)) { 
    c514:	2e 43       	mov	#2,	r14	;r3 As==10
    c516:	4f 49       	mov.b	r9,	r15	
    c518:	b0 12 68 c4 	call	#0xc468	
    c51c:	0f 93       	tst	r15		
    c51e:	68 24       	jz	$+210    	;abs 0xc5f0
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		if(port == 1) {
    c520:	1b 93       	cmp	#1,	r11	;r3 As==01
    c522:	09 20       	jnz	$+20     	;abs 0xc536
			P1DIR &= ~bit;					// make sure to clear OUT flag for the pin                 
    c524:	4f 4a       	mov.b	r10,	r15	
    c526:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    c528:	c2 ff 22 00 	and.b	r15,	&0x0022	
  			P1OUT &= ~bit;					// setting out to LOW enables pull-down                     
    c52c:	c2 ff 21 00 	and.b	r15,	&0x0021	
			P1REN |=  bit; 	                // enable pull-up/down 
    c530:	c2 da 27 00 	bis.b	r10,	&0x0027	
    c534:	54 3c       	jmp	$+170    	;abs 0xc5de
		}
		else if(port == 2) {
    c536:	2b 93       	cmp	#2,	r11	;r3 As==10
    c538:	52 20       	jnz	$+166    	;abs 0xc5de
			P2DIR &= ~bit;					// make sure to clear OUT flag for the pin                 
    c53a:	4f 4a       	mov.b	r10,	r15	
    c53c:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    c53e:	c2 ff 2a 00 	and.b	r15,	&0x002a	
  			P2OUT &= ~bit;					// setting out to LOW enables pull-down                     
    c542:	c2 ff 29 00 	and.b	r15,	&0x0029	
			P2REN |=  bit; 	                // enable pull-up/down 
    c546:	c2 da 2f 00 	bis.b	r10,	&0x002f	
    c54a:	49 3c       	jmp	$+148    	;abs 0xc5de
		}
		break;
	case PIN_FUNCTION_OUTPUT:
		if(!pin_has_capabilities(pin, PIN_CAP_OUTPUT)) { 
    c54c:	2e 42       	mov	#4,	r14	;r2 As==10
    c54e:	4f 49       	mov.b	r9,	r15	
    c550:	b0 12 68 c4 	call	#0xc468	
    c554:	0f 93       	tst	r15		
    c556:	4c 24       	jz	$+154    	;abs 0xc5f0
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		if(port == 1) {
    c558:	1b 93       	cmp	#1,	r11	;r3 As==01
    c55a:	08 20       	jnz	$+18     	;abs 0xc56c
			P1DIR |=  bit;					// set direction to out                 
    c55c:	c2 da 22 00 	bis.b	r10,	&0x0022	
  			P1OUT &= ~bit;					// set to LOW initially                     
    c560:	7a e3       	xor.b	#-1,	r10	;r3 As==11
    c562:	c2 fa 21 00 	and.b	r10,	&0x0021	
			P1REN &= ~bit; 	                // disable pull-up/down 
    c566:	c2 fa 27 00 	and.b	r10,	&0x0027	
    c56a:	39 3c       	jmp	$+116    	;abs 0xc5de
		}
		else if(port == 2) {
    c56c:	2b 93       	cmp	#2,	r11	;r3 As==10
    c56e:	37 20       	jnz	$+112    	;abs 0xc5de
			P2DIR |=  bit;					// set direction to out                 
    c570:	c2 da 2a 00 	bis.b	r10,	&0x002a	
  			P2OUT &= ~bit;					// set to LOW initially                     
    c574:	7a e3       	xor.b	#-1,	r10	;r3 As==11
    c576:	c2 fa 29 00 	and.b	r10,	&0x0029	
			P2REN &= ~bit; 	                // disable pull-up/down 
    c57a:	c2 fa 2f 00 	and.b	r10,	&0x002f	
    c57e:	2f 3c       	jmp	$+96     	;abs 0xc5de
		}
		break;
	case PIN_FUNCTION_ANALOG_IN:
		if(!pin_has_capabilities(pin, PIN_CAP_ANALOG_IN)) { 
    c580:	3e 42       	mov	#8,	r14	;r2 As==11
    c582:	4f 49       	mov.b	r9,	r15	
    c584:	b0 12 68 c4 	call	#0xc468	
    c588:	0f 93       	tst	r15		
    c58a:	32 24       	jz	$+102    	;abs 0xc5f0
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		P1DIR    &= ~bit;					// make sure to clear OUT flag for the pin                 
    c58c:	7a e3       	xor.b	#-1,	r10	;r3 As==11
    c58e:	c2 fa 22 00 	and.b	r10,	&0x0022	
		P1REN &= ~bit; 	                	// disable pull-up/down 
    c592:	c2 fa 27 00 	and.b	r10,	&0x0027	

		// VCC as +VRef, VSS as -VRef, 16 x ADC10CLKs
   		ADC10CTL0 = SREF_0 + ADC10SHT_2 + REFON + ADC10ON;
    c596:	b2 40 30 10 	mov	#4144,	&0x01b0	;#0x1030
    c59a:	b0 01 
    c59c:	20 3c       	jmp	$+66     	;abs 0xc5de

		break;
	case PIN_FUNCTION_PWM:
		if(!pin_has_capabilities(pin, PIN_CAP_PWM)) { 
    c59e:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    c5a2:	4f 49       	mov.b	r9,	r15	
    c5a4:	b0 12 68 c4 	call	#0xc468	
    c5a8:	0f 93       	tst	r15		
    c5aa:	19 20       	jnz	$+52     	;abs 0xc5de
    c5ac:	21 3c       	jmp	$+68     	;abs 0xc5f0
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		// TODO
		break;
	case PIN_FUNCTION_UARTRX:
		if(!pin_has_capabilities(pin, PIN_CAP_UARTRX) ||
    c5ae:	3e 40 20 00 	mov	#32,	r14	;#0x0020
    c5b2:	4f 49       	mov.b	r9,	r15	
    c5b4:	b0 12 68 c4 	call	#0xc468	
    c5b8:	0f 93       	tst	r15		
    c5ba:	1a 24       	jz	$+54     	;abs 0xc5f0
			pin_with_function(0, function)) { 
    c5bc:	7e 40 06 00 	mov.b	#6,	r14	;#0x0006
    c5c0:	09 3c       	jmp	$+20     	;abs 0xc5d4
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		// TODO	
		break;
	case PIN_FUNCTION_UARTTX:
		if(!pin_has_capabilities(pin, PIN_CAP_UARTTX) ||
    c5c2:	3e 40 40 00 	mov	#64,	r14	;#0x0040
    c5c6:	4f 49       	mov.b	r9,	r15	
    c5c8:	b0 12 68 c4 	call	#0xc468	
    c5cc:	0f 93       	tst	r15		
    c5ce:	10 24       	jz	$+34     	;abs 0xc5f0
			pin_with_function(0, function)) { 
    c5d0:	7e 40 07 00 	mov.b	#7,	r14	;#0x0007
    c5d4:	4f 43       	clr.b	r15		
    c5d6:	b0 12 e8 c2 	call	#0xc2e8	
			return PIN_STAT_ERR_UNSUPFUNC;
		}
		// TODO	
		break;
	case PIN_FUNCTION_UARTTX:
		if(!pin_has_capabilities(pin, PIN_CAP_UARTTX) ||
    c5da:	4f 93       	tst.b	r15		
    c5dc:	09 20       	jnz	$+20     	;abs 0xc5f0
		break;
	default:
		return PIN_STAT_ERR_UNSUPFUNC;
	}

	pin_set_curr_func(pin, function);
    c5de:	4e 48       	mov.b	r8,	r14	
    c5e0:	4f 49       	mov.b	r9,	r15	
    c5e2:	b0 12 8c c2 	call	#0xc28c	
    c5e6:	02 3c       	jmp	$+6      	;abs 0xc5ec
{
	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
	if((bit  = pin2bit(pin))  < 0) return bit;
    c5e8:	0b 4f       	mov	r15,	r11	
    c5ea:	03 3c       	jmp	$+8      	;abs 0xc5f2

	// see if PIN is already configured for the given function
	if(pin_function(pin) == function) { 
		return PIN_STAT_OK;
    c5ec:	0b 43       	clr	r11		
    c5ee:	01 3c       	jmp	$+4      	;abs 0xc5f2
		// TODO	
		break;
	case PIN_FUNCTION_UARTTX:
		if(!pin_has_capabilities(pin, PIN_CAP_UARTTX) ||
			pin_with_function(0, function)) { 
			return PIN_STAT_ERR_UNSUPFUNC;
    c5f0:	3b 43       	mov	#-1,	r11	;r3 As==11
	}

	pin_set_curr_func(pin, function);

	return PIN_STAT_OK;
}
    c5f2:	0f 4b       	mov	r11,	r15	
    c5f4:	38 41       	pop	r8		
    c5f6:	39 41       	pop	r9		
    c5f8:	3a 41       	pop	r10		
    c5fa:	3b 41       	pop	r11		
    c5fc:	30 41       	ret			

0000c5fe <pin_clear>:

int pin_clear(unsigned char pin)
{
    c5fe:	0b 12       	push	r11		
    c600:	0a 12       	push	r10		
    c602:	4a 4f       	mov.b	r15,	r10	
	unsigned char pf = pin_function(pin);
    c604:	b0 12 bc c2 	call	#0xc2bc	
 
	if(pf != PIN_FUNCTION_OUTPUT) { 
    c608:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c60c:	15 20       	jnz	$+44     	;abs 0xc638
	}

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
    c60e:	4f 4a       	mov.b	r10,	r15	
    c610:	b0 12 44 c2 	call	#0xc244	
    c614:	0b 4f       	mov	r15,	r11	
    c616:	0f 93       	tst	r15		
    c618:	14 38       	jl	$+42     	;abs 0xc642
	if((bit  = pin2bit(pin))  < 0) return bit;
    c61a:	4f 4a       	mov.b	r10,	r15	
    c61c:	b0 12 5e c2 	call	#0xc25e	
    c620:	0f 93       	tst	r15		
    c622:	0c 38       	jl	$+26     	;abs 0xc63c

	if(port == 1) {
    c624:	1b 93       	cmp	#1,	r11	;r3 As==01
    c626:	03 20       	jnz	$+8      	;abs 0xc62e
  		P1OUT &= ~bit;					// set to LOW                   
    c628:	c2 cf 21 00 	bic.b	r15,	&0x0021	
    c62c:	09 3c       	jmp	$+20     	;abs 0xc640
	}
	else if(port == 2) {
    c62e:	2b 93       	cmp	#2,	r11	;r3 As==10
    c630:	07 20       	jnz	$+16     	;abs 0xc640
  		P2OUT &= ~bit;					// set to LOW                    
    c632:	c2 cf 29 00 	bic.b	r15,	&0x0029	
    c636:	04 3c       	jmp	$+10     	;abs 0xc640
int pin_clear(unsigned char pin)
{
	unsigned char pf = pin_function(pin);
 
	if(pf != PIN_FUNCTION_OUTPUT) { 
		return PIN_STAT_ERR_UNSUPFUNC;
    c638:	3b 43       	mov	#-1,	r11	;r3 As==11
    c63a:	03 3c       	jmp	$+8      	;abs 0xc642

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
	if((bit  = pin2bit(pin))  < 0) return bit;
    c63c:	0b 4f       	mov	r15,	r11	
    c63e:	01 3c       	jmp	$+4      	;abs 0xc642
	}
	else if(port == 2) {
  		P2OUT &= ~bit;					// set to LOW                    
	}

	return PIN_STAT_OK;
    c640:	0b 43       	clr	r11		
}
    c642:	0f 4b       	mov	r11,	r15	
    c644:	3a 41       	pop	r10		
    c646:	3b 41       	pop	r11		
    c648:	30 41       	ret			

0000c64a <pin_set>:

int pin_set(unsigned char pin)
{
    c64a:	0b 12       	push	r11		
    c64c:	0a 12       	push	r10		
    c64e:	4a 4f       	mov.b	r15,	r10	
	unsigned char pf = pin_function(pin);
    c650:	b0 12 bc c2 	call	#0xc2bc	
 
	if(pf != PIN_FUNCTION_OUTPUT) { 
    c654:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c658:	15 20       	jnz	$+44     	;abs 0xc684
	}

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
    c65a:	4f 4a       	mov.b	r10,	r15	
    c65c:	b0 12 44 c2 	call	#0xc244	
    c660:	0b 4f       	mov	r15,	r11	
    c662:	0f 93       	tst	r15		
    c664:	14 38       	jl	$+42     	;abs 0xc68e
	if((bit  = pin2bit(pin))  < 0) return bit;
    c666:	4f 4a       	mov.b	r10,	r15	
    c668:	b0 12 5e c2 	call	#0xc25e	
    c66c:	0f 93       	tst	r15		
    c66e:	0c 38       	jl	$+26     	;abs 0xc688

	if(port == 1) {
    c670:	1b 93       	cmp	#1,	r11	;r3 As==01
    c672:	03 20       	jnz	$+8      	;abs 0xc67a
  		P1OUT |= bit;					// set to HIGH 
    c674:	c2 df 21 00 	bis.b	r15,	&0x0021	
    c678:	09 3c       	jmp	$+20     	;abs 0xc68c
	}
	else if(port == 2) {
    c67a:	2b 93       	cmp	#2,	r11	;r3 As==10
    c67c:	07 20       	jnz	$+16     	;abs 0xc68c
  		P2OUT |= bit;					// set to HIGH               
    c67e:	c2 df 29 00 	bis.b	r15,	&0x0029	
    c682:	04 3c       	jmp	$+10     	;abs 0xc68c
int pin_set(unsigned char pin)
{
	unsigned char pf = pin_function(pin);
 
	if(pf != PIN_FUNCTION_OUTPUT) { 
		return PIN_STAT_ERR_UNSUPFUNC;
    c684:	3b 43       	mov	#-1,	r11	;r3 As==11
    c686:	03 3c       	jmp	$+8      	;abs 0xc68e

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
	if((bit  = pin2bit(pin))  < 0) return bit;
    c688:	0b 4f       	mov	r15,	r11	
    c68a:	01 3c       	jmp	$+4      	;abs 0xc68e
	}
	else if(port == 2) {
  		P2OUT |= bit;					// set to HIGH               
	}

	return PIN_STAT_OK;
    c68c:	0b 43       	clr	r11		
}
    c68e:	0f 4b       	mov	r11,	r15	
    c690:	3a 41       	pop	r10		
    c692:	3b 41       	pop	r11		
    c694:	30 41       	ret			

0000c696 <pin_toggle>:

int pin_toggle(unsigned char pin)
{
    c696:	0b 12       	push	r11		
    c698:	0a 12       	push	r10		
    c69a:	4a 4f       	mov.b	r15,	r10	
	unsigned char pf = pin_function(pin);
    c69c:	b0 12 bc c2 	call	#0xc2bc	
 
	if(pf != PIN_FUNCTION_OUTPUT)  { 
    c6a0:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c6a4:	15 20       	jnz	$+44     	;abs 0xc6d0
	}

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
    c6a6:	4f 4a       	mov.b	r10,	r15	
    c6a8:	b0 12 44 c2 	call	#0xc244	
    c6ac:	0b 4f       	mov	r15,	r11	
    c6ae:	0f 93       	tst	r15		
    c6b0:	14 38       	jl	$+42     	;abs 0xc6da
	if((bit  = pin2bit(pin))  < 0) return bit;
    c6b2:	4f 4a       	mov.b	r10,	r15	
    c6b4:	b0 12 5e c2 	call	#0xc25e	
    c6b8:	0f 93       	tst	r15		
    c6ba:	0c 38       	jl	$+26     	;abs 0xc6d4

	if(port == 1) {
    c6bc:	1b 93       	cmp	#1,	r11	;r3 As==01
    c6be:	03 20       	jnz	$+8      	;abs 0xc6c6
  		P1OUT ^= bit;					// toggle 
    c6c0:	c2 ef 21 00 	xor.b	r15,	&0x0021	
    c6c4:	09 3c       	jmp	$+20     	;abs 0xc6d8
	}
	else if(port == 2) {
    c6c6:	2b 93       	cmp	#2,	r11	;r3 As==10
    c6c8:	07 20       	jnz	$+16     	;abs 0xc6d8
  		P2OUT ^= bit;					// toggle           
    c6ca:	c2 ef 29 00 	xor.b	r15,	&0x0029	
    c6ce:	04 3c       	jmp	$+10     	;abs 0xc6d8
int pin_toggle(unsigned char pin)
{
	unsigned char pf = pin_function(pin);
 
	if(pf != PIN_FUNCTION_OUTPUT)  { 
		return PIN_STAT_ERR_UNSUPFUNC;
    c6d0:	3b 43       	mov	#-1,	r11	;r3 As==11
    c6d2:	03 3c       	jmp	$+8      	;abs 0xc6da

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
	if((bit  = pin2bit(pin))  < 0) return bit;
    c6d4:	0b 4f       	mov	r15,	r11	
    c6d6:	01 3c       	jmp	$+4      	;abs 0xc6da
	}
	else if(port == 2) {
  		P2OUT ^= bit;					// toggle           
	}

	return PIN_STAT_OK;
    c6d8:	0b 43       	clr	r11		
}
    c6da:	0f 4b       	mov	r11,	r15	
    c6dc:	3a 41       	pop	r10		
    c6de:	3b 41       	pop	r11		
    c6e0:	30 41       	ret			

0000c6e2 <pin_digital_read>:

int pin_digital_read(unsigned char pin)
{
    c6e2:	0b 12       	push	r11		
    c6e4:	0a 12       	push	r10		
    c6e6:	4a 4f       	mov.b	r15,	r10	
	unsigned char pf = pin_function(pin);
    c6e8:	b0 12 bc c2 	call	#0xc2bc	
 
	if(pf != PIN_FUNCTION_OUTPUT && pf != PIN_FUNCTION_INPUT_FLOAT && 
    c6ec:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c6f0:	09 24       	jz	$+20     	;abs 0xc704
    c6f2:	4f 93       	tst.b	r15		
    c6f4:	07 24       	jz	$+16     	;abs 0xc704
    c6f6:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c6f8:	05 24       	jz	$+12     	;abs 0xc704
	   pf != PIN_FUNCTION_INPUT_PULLUP && pf != PIN_FUNCTION_INPUT_PULLDOWN
    c6fa:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c6fc:	03 24       	jz	$+8      	;abs 0xc704
	   && pf != PIN_FUNCTION_PWM) { 
    c6fe:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    c702:	19 20       	jnz	$+52     	;abs 0xc736
	}

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
    c704:	4f 4a       	mov.b	r10,	r15	
    c706:	b0 12 44 c2 	call	#0xc244	
    c70a:	0b 4f       	mov	r15,	r11	
    c70c:	0f 93       	tst	r15		
    c70e:	16 38       	jl	$+46     	;abs 0xc73c
	if((bit  = pin2bit(pin))  < 0) return bit;
    c710:	4f 4a       	mov.b	r10,	r15	
    c712:	b0 12 5e c2 	call	#0xc25e	
    c716:	0f 93       	tst	r15		
    c718:	10 38       	jl	$+34     	;abs 0xc73a

	if(port == 1) {
    c71a:	1b 93       	cmp	#1,	r11	;r3 As==01
    c71c:	04 20       	jnz	$+10     	;abs 0xc726
  		return ((P1IN & bit) == bit ? 1 : 0);	// read and return 
    c71e:	5e 42 20 00 	mov.b	&0x0020,r14	
    c722:	0e ff       	and	r15,	r14	
    c724:	04 3c       	jmp	$+10     	;abs 0xc72e
	}

	return ((P2IN & bit) == bit ? 1 : 0);	// read and return 
    c726:	5e 42 28 00 	mov.b	&0x0028,r14	
    c72a:	0e ff       	and	r15,	r14	
    c72c:	1b 43       	mov	#1,	r11	;r3 As==01
    c72e:	0e 9f       	cmp	r15,	r14	
    c730:	05 24       	jz	$+12     	;abs 0xc73c
    c732:	0b 43       	clr	r11		
    c734:	03 3c       	jmp	$+8      	;abs 0xc73c
	unsigned char pf = pin_function(pin);
 
	if(pf != PIN_FUNCTION_OUTPUT && pf != PIN_FUNCTION_INPUT_FLOAT && 
	   pf != PIN_FUNCTION_INPUT_PULLUP && pf != PIN_FUNCTION_INPUT_PULLDOWN
	   && pf != PIN_FUNCTION_PWM) { 
		return PIN_STAT_ERR_UNSUPFUNC;
    c736:	3b 43       	mov	#-1,	r11	;r3 As==11
    c738:	01 3c       	jmp	$+4      	;abs 0xc73c

	int port;
	int bit;

	if((port = pin2port(pin)) < 0) return port;
	if((bit  = pin2bit(pin))  < 0) return bit;
    c73a:	0b 4f       	mov	r15,	r11	
	if(port == 1) {
  		return ((P1IN & bit) == bit ? 1 : 0);	// read and return 
	}

	return ((P2IN & bit) == bit ? 1 : 0);	// read and return 
}
    c73c:	0f 4b       	mov	r11,	r15	
    c73e:	3a 41       	pop	r10		
    c740:	3b 41       	pop	r11		
    c742:	30 41       	ret			

0000c744 <pin_analog_read>:

int pin_analog_read(unsigned char pin)
{
    c744:	0b 12       	push	r11		
    c746:	4b 4f       	mov.b	r15,	r11	
	unsigned char pf = pin_function(pin);
    c748:	b0 12 bc c2 	call	#0xc2bc	
 
	if(pf != PIN_FUNCTION_OUTPUT && pf != PIN_FUNCTION_ANALOG_IN) { 
    c74c:	7f 50 fd ff 	add.b	#-3,	r15	;#0xfffd
    c750:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c752:	1b 2c       	jc	$+56     	;abs 0xc78a
		return PIN_STAT_ERR_UNSUPFUNC;
	}

	int s;

	if((s = pin2port(pin)) < 0) return s;
    c754:	4f 4b       	mov.b	r11,	r15	
    c756:	b0 12 44 c2 	call	#0xc244	
    c75a:	0f 93       	tst	r15		
    c75c:	17 38       	jl	$+48     	;abs 0xc78c
	if((s = pin2bit(pin))  < 0) return s;
    c75e:	4f 4b       	mov.b	r11,	r15	
    c760:	b0 12 5e c2 	call	#0xc25e	
    c764:	0f 93       	tst	r15		
    c766:	12 38       	jl	$+38     	;abs 0xc78c

	// configure channel
   	ADC10CTL1 = 0xF000 & (pin << 12); 
    c768:	4f 4b       	mov.b	r11,	r15	
    c76a:	8f 10       	swpb	r15		
    c76c:	0f 5f       	rla	r15		
    c76e:	0f 5f       	rla	r15		
    c770:	0f 5f       	rla	r15		
    c772:	0f 5f       	rla	r15		
    c774:	82 4f b2 01 	mov	r15,	&0x01b2	

    ADC10CTL0 |= ENC + ADC10SC;             // sample 
    c778:	b2 d0 03 00 	bis	#3,	&0x01b0	;#0x0003
    c77c:	b0 01 
    while (ADC10CTL1 & ADC10BUSY);          // wait while ADC10BUSY
    c77e:	92 b3 b2 01 	bit	#1,	&0x01b2	;r3 As==01
    c782:	fd 23       	jnz	$-4      	;abs 0xc77e

	return ADC10MEM;
    c784:	1f 42 b4 01 	mov	&0x01b4,r15	
    c788:	01 3c       	jmp	$+4      	;abs 0xc78c
int pin_analog_read(unsigned char pin)
{
	unsigned char pf = pin_function(pin);
 
	if(pf != PIN_FUNCTION_OUTPUT && pf != PIN_FUNCTION_ANALOG_IN) { 
		return PIN_STAT_ERR_UNSUPFUNC;
    c78a:	3f 43       	mov	#-1,	r15	;r3 As==11

    ADC10CTL0 |= ENC + ADC10SC;             // sample 
    while (ADC10CTL1 & ADC10BUSY);          // wait while ADC10BUSY

	return ADC10MEM;
}
    c78c:	3b 41       	pop	r11		
    c78e:	30 41       	ret			

0000c790 <pin_pulselength_read>:

int pin_pulselength_read(unsigned char pin)
{
	unsigned char pf = pin_function(pin);
    c790:	b0 12 bc c2 	call	#0xc2bc	
 
	if(pf != PIN_FUNCTION_INPUT_FLOAT && pf != PIN_FUNCTION_INPUT_PULLUP && 
    c794:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c798:	02 28       	jnc	$+6      	;abs 0xc79e
	   pf != PIN_FUNCTION_INPUT_PULLDOWN) { 
		return PIN_STAT_ERR_UNSUPFUNC;
    c79a:	3f 43       	mov	#-1,	r15	;r3 As==11
    c79c:	30 41       	ret			
	}

	// TODO
	return 0;
    c79e:	0f 43       	clr	r15		
}
    c7a0:	30 41       	ret			

0000c7a2 <packet_do_handle>:
	}
};

void packet_do_handle()
{
	if(packet_receive(&inp, PACKET_INBOUND_START) == PACKET_STAT_OK) {
    c7a2:	7e 40 24 00 	mov.b	#36,	r14	;#0x0024
    c7a6:	3f 40 d6 02 	mov	#726,	r15	;#0x02d6
    c7aa:	b0 12 48 ca 	call	#0xca48	
    c7ae:	0f 93       	tst	r15		
    c7b0:	0e 20       	jnz	$+30     	;abs 0xc7ce
		if(packet_process_received(&packet_handlers, &inp) == PACKET_STAT_ERR_UNKPACK) {
    c7b2:	3e 40 d6 02 	mov	#726,	r14	;#0x02d6
    c7b6:	3f 40 00 02 	mov	#512,	r15	;#0x0200
    c7ba:	b0 12 b6 ca 	call	#0xcab6	
    c7be:	3f 90 fd ff 	cmp	#-3,	r15	;#0xfffd
    c7c2:	08 20       	jnz	$+18     	;abs 0xc7d4
			send_status_packet(PACKET_RETURN_INVALID_PACKET);
    c7c4:	7f 50 06 00 	add.b	#6,	r15	;#0x0006
    c7c8:	b0 12 d6 c7 	call	#0xc7d6	
    c7cc:	30 41       	ret			
		}
	}
	else {
		send_status_packet(PACKET_RETURN_BAD_PACKET);
    c7ce:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c7d0:	b0 12 d6 c7 	call	#0xc7d6	
    c7d4:	30 41       	ret			

0000c7d6 <send_status_packet>:
 * IN-bound packet instance.
 */
packet inp;

void send_status_packet(unsigned char stat)
{
    c7d6:	0b 12       	push	r11		
	packet_data_out_status *pd = (packet_data_out_status *)&outp.data[0];

	outp.start	= PACKET_OUTBOUND_START;
    c7d8:	3b 40 1a 03 	mov	#794,	r11	;#0x031a
    c7dc:	fb 40 2b 00 	mov.b	#43,	0(r11)	;#0x002b, 0x0000(r11)
    c7e0:	00 00 
	outp.length	= 5;
    c7e2:	fb 40 05 00 	mov.b	#5,	1(r11)	;#0x0005, 0x0001(r11)
    c7e6:	01 00 
	outp.type 	= PACKET_OUT_STATUS;
    c7e8:	db 43 02 00 	mov.b	#1,	2(r11)	;r3 As==01, 0x0002(r11)
	pd->status  = stat;
    c7ec:	cb 4f 03 00 	mov.b	r15,	3(r11)	;0x0003(r11)
	outp.crc	= packet_calc_crc(&outp);
    c7f0:	0f 4b       	mov	r11,	r15	
    c7f2:	b0 12 b2 c9 	call	#0xc9b2	
    c7f6:	cb 4f 43 00 	mov.b	r15,	67(r11)	;0x0043(r11)

	packet_send(&outp);
    c7fa:	0f 4b       	mov	r11,	r15	
    c7fc:	b0 12 f2 c9 	call	#0xc9f2	
}
    c800:	3b 41       	pop	r11		
    c802:	30 41       	ret			

0000c804 <handle_packet_null>:
#include "core_handlers.h"
#include "rocketcore.h"

int handle_packet_null(unsigned char length, unsigned char *data)
{
	send_status_packet(PACKET_RETURN_ACK);
    c804:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c806:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c80a:	0f 43       	clr	r15		
    c80c:	30 41       	ret			

0000c80e <handle_packet_reserved>:

int handle_packet_reserved(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c80e:	4f 43       	clr.b	r15		
    c810:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c814:	0f 43       	clr	r15		
    c816:	30 41       	ret			

0000c818 <handle_packet_system_info>:

int handle_packet_system_info(unsigned char length, unsigned char *data)
{
    c818:	0b 12       	push	r11		
	packet_data_out_system_info *pd = (packet_data_out_system_info *)&outp.data[0];

	outp.start	= PACKET_OUTBOUND_START;
    c81a:	3b 40 1a 03 	mov	#794,	r11	;#0x031a
    c81e:	fb 40 2b 00 	mov.b	#43,	0(r11)	;#0x002b, 0x0000(r11)
    c822:	00 00 
	outp.length	= 7;
    c824:	fb 40 07 00 	mov.b	#7,	1(r11)	;#0x0007, 0x0001(r11)
    c828:	01 00 
	outp.type 	= PACKET_OUT_SYSTEM_INFO;
    c82a:	eb 43 02 00 	mov.b	#2,	2(r11)	;r3 As==10, 0x0002(r11)
	
	// TODO replace 0xCAFFEE with data from constants
	pd->board_type	= 0xCA;
    c82e:	f2 40 ca ff 	mov.b	#-54,	&0x031d	;#0xffca
    c832:	1d 03 
	pd->mcu_type	= 0xFF;
    c834:	f2 43 1e 03 	mov.b	#-1,	&0x031e	;r3 As==11
	pd->firmware_rev= 0xEE;
    c838:	f2 40 ee ff 	mov.b	#-18,	&0x031f	;#0xffee
    c83c:	1f 03 

	outp.crc	= packet_calc_crc(&outp);
    c83e:	0f 4b       	mov	r11,	r15	
    c840:	b0 12 b2 c9 	call	#0xc9b2	
    c844:	cb 4f 43 00 	mov.b	r15,	67(r11)	;0x0043(r11)

	packet_send(&outp);
    c848:	0f 4b       	mov	r11,	r15	
    c84a:	b0 12 f2 c9 	call	#0xc9f2	

	return PACKET_STAT_OK;
}
    c84e:	0f 43       	clr	r15		
    c850:	3b 41       	pop	r11		
    c852:	30 41       	ret			

0000c854 <handle_packet_device_control>:

int handle_packet_device_control(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c854:	4f 43       	clr.b	r15		
    c856:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c85a:	0f 43       	clr	r15		
    c85c:	30 41       	ret			

0000c85e <handle_packet_pin_function>:

int handle_packet_pin_function(unsigned char length, unsigned char *data)
{
    c85e:	0b 12       	push	r11		
    c860:	0d 4e       	mov	r14,	r13	
	int s;

	// check if length matches for packet-data
	if(length != 2) {
    c862:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c864:	06 24       	jz	$+14     	;abs 0xc872
		send_status_packet(PACKET_RETURN_INAVLID_DATA);
    c866:	6f 42       	mov.b	#4,	r15	;r2 As==10
    c868:	b0 12 d6 c7 	call	#0xc7d6	
		return PACKET_STAT_ERR_DATA;
    c86c:	3b 40 fc ff 	mov	#-4,	r11	;#0xfffc
    c870:	0e 3c       	jmp	$+30     	;abs 0xc88e
	}

	packet_data_in_pin_function *pd = (packet_data_in_pin_function *)&data[0];

	if((s = pin_setup(pd->pin, pd->function)) != PACKET_STAT_OK) {
    c872:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    c876:	6f 4d       	mov.b	@r13,	r15	
    c878:	b0 12 80 c4 	call	#0xc480	
    c87c:	0b 4f       	mov	r15,	r11	
    c87e:	0f 93       	tst	r15		
    c880:	03 24       	jz	$+8      	;abs 0xc888
		send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
    c882:	7f 40 05 00 	mov.b	#5,	r15	;#0x0005
    c886:	01 3c       	jmp	$+4      	;abs 0xc88a
	}
	else {
		send_status_packet(PACKET_RETURN_ACK);
    c888:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c88a:	b0 12 d6 c7 	call	#0xc7d6	
	}

	return s;
}
    c88e:	0f 4b       	mov	r11,	r15	
    c890:	3b 41       	pop	r11		
    c892:	30 41       	ret			

0000c894 <handle_packet_pin_control>:

int handle_packet_pin_control(unsigned char length, unsigned char *data)
{
    c894:	0b 12       	push	r11		
    c896:	0a 12       	push	r10		
    c898:	0a 4e       	mov	r14,	r10	
	int s = PACKET_STAT_OK;

	// check if length matches for packet-data
	if(length != 2) {
    c89a:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c89c:	02 24       	jz	$+6      	;abs 0xc8a2
		send_status_packet(PACKET_RETURN_INAVLID_DATA);
    c89e:	6f 42       	mov.b	#4,	r15	;r2 As==10
    c8a0:	62 3c       	jmp	$+198    	;abs 0xc966
		return PACKET_STAT_ERR_DATA;
	}

	packet_data_in_pin_control *pd = (packet_data_in_pin_control *)&data[0];

	switch(pd->control) {
    c8a2:	7f 40 05 00 	mov.b	#5,	r15	;#0x0005
    c8a6:	5f 9e 01 00 	cmp.b	1(r14),	r15	;0x0001(r14)
    c8aa:	5d 28       	jnc	$+188    	;abs 0xc966
    c8ac:	5f 4e 01 00 	mov.b	1(r14),	r15	;0x0001(r14)
    c8b0:	0f 5f       	rla	r15		
    c8b2:	10 4f b6 c8 	br	-14154(r15)	;0xc8b6(r15)
    c8b6:	c2 c8 ca c8 	bic.b	r8,	&0xc8ca	
    c8ba:	d2 c8 e6 c8 	bic.b	-14106(r8),&0xc90e	;0xc8e6(r8)
    c8be:	0e c9 
    c8c0:	5a c9 6f 4e 	bic.b	20079(r9),r10	;0x4e6f(r9)
		case PIN_CONTROL_CLEAR:
			if((s = pin_clear(pd->pin)) != PACKET_STAT_OK) {
    c8c4:	b0 12 fe c5 	call	#0xc5fe	
    c8c8:	07 3c       	jmp	$+16     	;abs 0xc8d8
			else {
				send_status_packet(PACKET_RETURN_ACK);
			}
			break;
		case PIN_CONTROL_SET:
			if((s = pin_set(pd->pin)) != PACKET_STAT_OK) {
    c8ca:	6f 4e       	mov.b	@r14,	r15	
    c8cc:	b0 12 4a c6 	call	#0xc64a	
    c8d0:	03 3c       	jmp	$+8      	;abs 0xc8d8
			else {
				send_status_packet(PACKET_RETURN_ACK);
			}
			break;
		case PIN_CONTROL_TOGGLE:
			if((s = pin_toggle(pd->pin)) != PACKET_STAT_OK) {
    c8d2:	6f 4e       	mov.b	@r14,	r15	
    c8d4:	b0 12 96 c6 	call	#0xc696	
    c8d8:	0b 4f       	mov	r15,	r11	
    c8da:	0f 93       	tst	r15		
    c8dc:	1e 20       	jnz	$+62     	;abs 0xc91a
				send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
			}
			else {
				send_status_packet(PACKET_RETURN_ACK);
    c8de:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c8e0:	b0 12 d6 c7 	call	#0xc7d6	
    c8e4:	44 3c       	jmp	$+138    	;abs 0xc96e
			}
			break;
		case PIN_CONTROL_DIGITAL_READ:
			if((s = pin_digital_read(pd->pin)) < 0) {
    c8e6:	6f 4e       	mov.b	@r14,	r15	
    c8e8:	b0 12 e2 c6 	call	#0xc6e2	
    c8ec:	0b 4f       	mov	r15,	r11	
    c8ee:	0f 93       	tst	r15		
    c8f0:	14 38       	jl	$+42     	;abs 0xc91a
				send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
			}
			else {
				packet_data_out_digital_pin_read *pdo = (packet_data_out_digital_pin_read *)&outp.data[0];

				outp.start	= PACKET_OUTBOUND_START;
    c8f2:	f2 40 2b 00 	mov.b	#43,	&0x031a	;#0x002b
    c8f6:	1a 03 
				outp.length	= 6;
    c8f8:	f2 40 06 00 	mov.b	#6,	&0x031b	;#0x0006
    c8fc:	1b 03 
				outp.type 	= PACKET_OUT_DIGITAL_PIN_READ;
    c8fe:	f2 40 03 00 	mov.b	#3,	&0x031c	;#0x0003
    c902:	1c 03 
	
				pdo->pin   = pd->pin;
    c904:	e2 4a 1d 03 	mov.b	@r10,	&0x031d	
				pdo->state = s;
    c908:	c2 4f 1e 03 	mov.b	r15,	&0x031e	
    c90c:	1b 3c       	jmp	$+56     	;abs 0xc944

				packet_send(&outp);
			}
			break;
		case PIN_CONTROL_ANALOG_READ:
			if((s = pin_analog_read(pd->pin)) < 0) {
    c90e:	6f 4e       	mov.b	@r14,	r15	
    c910:	b0 12 44 c7 	call	#0xc744	
    c914:	0b 4f       	mov	r15,	r11	
    c916:	0f 93       	tst	r15		
    c918:	03 34       	jge	$+8      	;abs 0xc920
				send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
    c91a:	7f 40 05 00 	mov.b	#5,	r15	;#0x0005
    c91e:	e0 3f       	jmp	$-62     	;abs 0xc8e0
			}
			else {
				packet_data_out_analog_pin_read *pdo = (packet_data_out_analog_pin_read *)&outp.data[0];

				outp.start	= PACKET_OUTBOUND_START;
    c920:	f2 40 2b 00 	mov.b	#43,	&0x031a	;#0x002b
    c924:	1a 03 
				outp.length	= 7;
    c926:	f2 40 07 00 	mov.b	#7,	&0x031b	;#0x0007
    c92a:	1b 03 
				outp.type 	= PACKET_OUT_ANALOG_PIN_READ;
    c92c:	e2 42 1c 03 	mov.b	#4,	&0x031c	;r2 As==10
	
				pdo->pin       = pd->pin;
    c930:	e2 4a 1d 03 	mov.b	@r10,	&0x031d	
				pdo->value_lsb = (0x00FF & s);
    c934:	c2 4f 1e 03 	mov.b	r15,	&0x031e	
				pdo->value_msb = (0x0F00 & s) >> 8;
    c938:	3f f0 00 0f 	and	#3840,	r15	;#0x0f00
    c93c:	8f 10       	swpb	r15		
    c93e:	8f 11       	sxt	r15		
    c940:	c2 4f 1f 03 	mov.b	r15,	&0x031f	

				outp.crc = packet_calc_crc(&outp);
    c944:	3f 40 1a 03 	mov	#794,	r15	;#0x031a
    c948:	b0 12 b2 c9 	call	#0xc9b2	
    c94c:	c2 4f 5d 03 	mov.b	r15,	&0x035d	

				packet_send(&outp);
    c950:	3f 40 1a 03 	mov	#794,	r15	;#0x031a
    c954:	b0 12 f2 c9 	call	#0xc9f2	
    c958:	0a 3c       	jmp	$+22     	;abs 0xc96e
			}
			break;
		case PIN_CONTROL_PULSELENGTH_READ:
			// TODO implement
			send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
    c95a:	7f 40 05 00 	mov.b	#5,	r15	;#0x0005
    c95e:	b0 12 d6 c7 	call	#0xc7d6	
	return s;
}

int handle_packet_pin_control(unsigned char length, unsigned char *data)
{
	int s = PACKET_STAT_OK;
    c962:	0b 43       	clr	r11		
    c964:	04 3c       	jmp	$+10     	;abs 0xc96e
		case PIN_CONTROL_PULSELENGTH_READ:
			// TODO implement
			send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
			break;
		default:
			send_status_packet(PACKET_RETURN_INVALID_PIN_COMMAND);
    c966:	b0 12 d6 c7 	call	#0xc7d6	
			s = PACKET_STAT_ERR_DATA;
    c96a:	3b 40 fc ff 	mov	#-4,	r11	;#0xfffc
	}

	return s;
}
    c96e:	0f 4b       	mov	r11,	r15	
    c970:	3a 41       	pop	r10		
    c972:	3b 41       	pop	r11		
    c974:	30 41       	ret			

0000c976 <handle_packet_pwm_function>:

int handle_packet_pwm_function(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c976:	4f 43       	clr.b	r15		
    c978:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c97c:	0f 43       	clr	r15		
    c97e:	30 41       	ret			

0000c980 <handle_packet_pwm_control>:

int handle_packet_pwm_control(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c980:	4f 43       	clr.b	r15		
    c982:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c986:	0f 43       	clr	r15		
    c988:	30 41       	ret			

0000c98a <handle_packet_serial_function>:

int handle_packet_serial_function(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c98a:	4f 43       	clr.b	r15		
    c98c:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c990:	0f 43       	clr	r15		
    c992:	30 41       	ret			

0000c994 <handle_packet_serial_data>:

int handle_packet_serial_data(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c994:	4f 43       	clr.b	r15		
    c996:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c99a:	0f 43       	clr	r15		
    c99c:	30 41       	ret			

0000c99e <handle_packet_external_interrupt_function>:

int handle_packet_external_interrupt_function(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c99e:	4f 43       	clr.b	r15		
    c9a0:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c9a4:	0f 43       	clr	r15		
    c9a6:	30 41       	ret			

0000c9a8 <handle_packet_reset>:

int handle_packet_reset(unsigned char length, unsigned char *data)
{
	// TODO define + implement
	send_status_packet(PACKET_RETURN_UNKNOWN);
    c9a8:	4f 43       	clr.b	r15		
    c9aa:	b0 12 d6 c7 	call	#0xc7d6	

	return PACKET_STAT_OK;
}
    c9ae:	0f 43       	clr	r15		
    c9b0:	30 41       	ret			

0000c9b2 <packet_calc_crc>:
 * 02111-1307 USA.  
 */

#include "packet.h"

unsigned char packet_calc_crc(packet *pkt) {
    c9b2:	0b 12       	push	r11		

	unsigned char i;
	unsigned char crc = 0;

	crc += pkt->start;
	crc += pkt->length;
    c9b4:	5d 4f 01 00 	mov.b	1(r15),	r13	;0x0001(r15)
    c9b8:	6e 4f       	mov.b	@r15,	r14	
    c9ba:	4e 5d       	add.b	r13,	r14	
	crc += pkt->type;
    c9bc:	5e 5f 02 00 	add.b	2(r15),	r14	;0x0002(r15)

	for(i = 0; i < pkt->length - 4; i++) {
    c9c0:	4c 43       	clr.b	r12		
    c9c2:	2d 82       	sub	#4,	r13	;r2 As==10
    c9c4:	04 3c       	jmp	$+10     	;abs 0xc9ce
		crc += pkt->data[i];
    c9c6:	0b 5f       	add	r15,	r11	
    c9c8:	5e 5b 03 00 	add.b	3(r11),	r14	;0x0003(r11)

	crc += pkt->start;
	crc += pkt->length;
	crc += pkt->type;

	for(i = 0; i < pkt->length - 4; i++) {
    c9cc:	5c 53       	inc.b	r12		
    c9ce:	4b 4c       	mov.b	r12,	r11	
    c9d0:	0b 9d       	cmp	r13,	r11	
    c9d2:	f9 3b       	jl	$-12     	;abs 0xc9c6
		crc += pkt->data[i];
	} 

	return crc;
}
    c9d4:	4f 4e       	mov.b	r14,	r15	
    c9d6:	3b 41       	pop	r11		
    c9d8:	30 41       	ret			

0000c9da <packet_check_crc>:

int	packet_check_crc(packet *pkt) {
    c9da:	0b 12       	push	r11		
    c9dc:	0b 4f       	mov	r15,	r11	

	if(packet_calc_crc(pkt) == pkt->crc) {
    c9de:	b0 12 b2 c9 	call	#0xc9b2	
		return 1;
    c9e2:	1e 43       	mov	#1,	r14	;r3 As==01
    c9e4:	5f 9b 43 00 	cmp.b	67(r11),r15	;0x0043(r11)
    c9e8:	01 24       	jz	$+4      	;abs 0xc9ec
    c9ea:	0e 43       	clr	r14		
	}

	return 0;
}
    c9ec:	0f 4e       	mov	r14,	r15	
    c9ee:	3b 41       	pop	r11		
    c9f0:	30 41       	ret			

0000c9f2 <packet_send>:

int packet_send(packet *pkt) {
    c9f2:	0b 12       	push	r11		
    c9f4:	0a 12       	push	r10		
    c9f6:	0b 4f       	mov	r15,	r11	

	unsigned char  i;

	// check length
	if(pkt->length - 4 > PACKET_MAX_DATA) {
    c9f8:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    c9fc:	3f 90 45 00 	cmp	#69,	r15	;#0x0045
    ca00:	1f 34       	jge	$+64     	;abs 0xca40
		return PACKET_STAT_ERR_LENGTH;
	}
 
	// write start byte
	packet_byte_to_sendq(pkt->start);
    ca02:	6f 4b       	mov.b	@r11,	r15	
    ca04:	b0 12 a8 c0 	call	#0xc0a8	

	// write length
	packet_byte_to_sendq(pkt->length);
    ca08:	5f 4b 01 00 	mov.b	1(r11),	r15	;0x0001(r11)
    ca0c:	b0 12 a8 c0 	call	#0xc0a8	

	// write type
	packet_byte_to_sendq(pkt->type);
    ca10:	5f 4b 02 00 	mov.b	2(r11),	r15	;0x0002(r11)
    ca14:	b0 12 a8 c0 	call	#0xc0a8	

	// write data
	for(i = 0; i < pkt->length - 4; i++) {	
    ca18:	4a 43       	clr.b	r10		
    ca1a:	06 3c       	jmp	$+14     	;abs 0xca28
		packet_byte_to_sendq(pkt->data[i]); 
    ca1c:	0e 5b       	add	r11,	r14	
    ca1e:	5f 4e 03 00 	mov.b	3(r14),	r15	;0x0003(r14)
    ca22:	b0 12 a8 c0 	call	#0xc0a8	

	// write type
	packet_byte_to_sendq(pkt->type);

	// write data
	for(i = 0; i < pkt->length - 4; i++) {	
    ca26:	5a 53       	inc.b	r10		
    ca28:	4e 4a       	mov.b	r10,	r14	
    ca2a:	5f 4b 01 00 	mov.b	1(r11),	r15	;0x0001(r11)
    ca2e:	2f 82       	sub	#4,	r15	;r2 As==10
    ca30:	0e 9f       	cmp	r15,	r14	
    ca32:	f4 3b       	jl	$-22     	;abs 0xca1c
		packet_byte_to_sendq(pkt->data[i]); 
	}

	// write crc 
	packet_byte_to_sendq(pkt->crc);
    ca34:	5f 4b 43 00 	mov.b	67(r11),r15	;0x0043(r11)
    ca38:	b0 12 a8 c0 	call	#0xc0a8	
	
	return PACKET_STAT_OK;
    ca3c:	0f 43       	clr	r15		
    ca3e:	01 3c       	jmp	$+4      	;abs 0xca42

	unsigned char  i;

	// check length
	if(pkt->length - 4 > PACKET_MAX_DATA) {
		return PACKET_STAT_ERR_LENGTH;
    ca40:	3f 43       	mov	#-1,	r15	;r3 As==11

	// write crc 
	packet_byte_to_sendq(pkt->crc);
	
	return PACKET_STAT_OK;
}
    ca42:	3a 41       	pop	r10		
    ca44:	3b 41       	pop	r11		
    ca46:	30 41       	ret			

0000ca48 <packet_receive>:

int packet_receive(packet *pkt, unsigned char start) {
    ca48:	0b 12       	push	r11		
    ca4a:	0a 12       	push	r10		
    ca4c:	09 12       	push	r9		
    ca4e:	0b 4f       	mov	r15,	r11	
    ca50:	4a 4e       	mov.b	r14,	r10	

	unsigned char  i;

	// discard everything until start byte found in buffer
	while(packet_byte_from_rcvq() != start);
    ca52:	b0 12 ce c0 	call	#0xc0ce	
    ca56:	4f 9a       	cmp.b	r10,	r15	
    ca58:	fc 23       	jnz	$-6      	;abs 0xca52

	pkt->start = start;
    ca5a:	cb 4a 00 00 	mov.b	r10,	0(r11)	;0x0000(r11)

	// read length
	pkt->length = packet_byte_from_rcvq();
    ca5e:	b0 12 ce c0 	call	#0xc0ce	
    ca62:	cb 4f 01 00 	mov.b	r15,	1(r11)	;0x0001(r11)
	
	// check length
	if(pkt->length - 4 > PACKET_MAX_DATA) {
    ca66:	4f 4f       	mov.b	r15,	r15	
    ca68:	3f 90 45 00 	cmp	#69,	r15	;#0x0045
    ca6c:	1d 34       	jge	$+60     	;abs 0xcaa8
		return PACKET_STAT_ERR_LENGTH;
	}
 
	// read type
	pkt->type = packet_byte_from_rcvq();
    ca6e:	b0 12 ce c0 	call	#0xc0ce	
    ca72:	cb 4f 02 00 	mov.b	r15,	2(r11)	;0x0002(r11)
 	
	// read data
	for(i = 0; i < pkt->length - 4; i++) {	
    ca76:	4a 43       	clr.b	r10		
    ca78:	06 3c       	jmp	$+14     	;abs 0xca86
		pkt->data[i] = packet_byte_from_rcvq();
    ca7a:	b0 12 ce c0 	call	#0xc0ce	
    ca7e:	09 5b       	add	r11,	r9	
    ca80:	c9 4f 03 00 	mov.b	r15,	3(r9)	;0x0003(r9)
 
	// read type
	pkt->type = packet_byte_from_rcvq();
 	
	// read data
	for(i = 0; i < pkt->length - 4; i++) {	
    ca84:	5a 53       	inc.b	r10		
    ca86:	49 4a       	mov.b	r10,	r9	
    ca88:	5f 4b 01 00 	mov.b	1(r11),	r15	;0x0001(r11)
    ca8c:	2f 82       	sub	#4,	r15	;r2 As==10
    ca8e:	09 9f       	cmp	r15,	r9	
    ca90:	f4 3b       	jl	$-22     	;abs 0xca7a
		pkt->data[i] = packet_byte_from_rcvq();
	}
	
	// read crc 
	pkt->crc = packet_byte_from_rcvq();
    ca92:	b0 12 ce c0 	call	#0xc0ce	
    ca96:	cb 4f 43 00 	mov.b	r15,	67(r11)	;0x0043(r11)
	
	// check crc
	if(!packet_check_crc(pkt)) {
    ca9a:	0f 4b       	mov	r11,	r15	
    ca9c:	b0 12 da c9 	call	#0xc9da	
    caa0:	0f 93       	tst	r15		
    caa2:	04 20       	jnz	$+10     	;abs 0xcaac
		return PACKET_STAT_ERR_CRC;
    caa4:	2f 83       	decd	r15		
    caa6:	03 3c       	jmp	$+8      	;abs 0xcaae
	// read length
	pkt->length = packet_byte_from_rcvq();
	
	// check length
	if(pkt->length - 4 > PACKET_MAX_DATA) {
		return PACKET_STAT_ERR_LENGTH;
    caa8:	3f 43       	mov	#-1,	r15	;r3 As==11
    caaa:	01 3c       	jmp	$+4      	;abs 0xcaae
	// check crc
	if(!packet_check_crc(pkt)) {
		return PACKET_STAT_ERR_CRC;
	}

	return PACKET_STAT_OK;
    caac:	0f 43       	clr	r15		
}
    caae:	39 41       	pop	r9		
    cab0:	3a 41       	pop	r10		
    cab2:	3b 41       	pop	r11		
    cab4:	30 41       	ret			

0000cab6 <packet_process_received>:

int packet_process_received(packet_rcv_handlers *rh, packet *pkt) {
    cab6:	0b 12       	push	r11		
    cab8:	0a 12       	push	r10		
    caba:	0c 4e       	mov	r14,	r12	

	int i;

    for(i = 0; i < rh->count; i++) {
    cabc:	6b 4f       	mov.b	@r15,	r11	
	}

	return PACKET_STAT_OK;
}

int packet_process_received(packet_rcv_handlers *rh, packet *pkt) {
    cabe:	0e 4f       	mov	r15,	r14	
    cac0:	2e 53       	incd	r14		

	int i;

    for(i = 0; i < rh->count; i++) {
    cac2:	0d 43       	clr	r13		
    cac4:	11 3c       	jmp	$+36     	;abs 0xcae8
		if(rh->handlers[i].type == pkt->type) {
    cac6:	6a 4e       	mov.b	@r14,	r10	
    cac8:	2e 52       	add	#4,	r14	;r2 As==10
    caca:	1d 53       	inc	r13		
    cacc:	5a 9c 02 00 	cmp.b	2(r12),	r10	;0x0002(r12)
    cad0:	0b 20       	jnz	$+24     	;abs 0xcae8
			// call handler function
    		return (rh->handlers[i].func)(pkt->length - 4, pkt->data);
    cad2:	0d 5d       	rla	r13		
    cad4:	0d 5d       	rla	r13		
    cad6:	0d 5f       	add	r15,	r13	
    cad8:	0e 4c       	mov	r12,	r14	
    cada:	3e 50 03 00 	add	#3,	r14	;#0x0003
    cade:	5f 4c 01 00 	mov.b	1(r12),	r15	;0x0001(r12)
    cae2:	6f 82       	sub.b	#4,	r15	;r2 As==10
    cae4:	ad 12       	call	@r13		
    cae6:	04 3c       	jmp	$+10     	;abs 0xcaf0

int packet_process_received(packet_rcv_handlers *rh, packet *pkt) {

	int i;

    for(i = 0; i < rh->count; i++) {
    cae8:	0d 9b       	cmp	r11,	r13	
    caea:	ed 3b       	jl	$-36     	;abs 0xcac6
			// call handler function
    		return (rh->handlers[i].func)(pkt->length - 4, pkt->data);
		}
    }

	return PACKET_STAT_ERR_UNKPACK;
    caec:	3f 40 fd ff 	mov	#-3,	r15	;#0xfffd
}
    caf0:	3a 41       	pop	r10		
    caf2:	3b 41       	pop	r11		
    caf4:	30 41       	ret			

0000caf6 <__divmodsi4>:
    caf6:	08 43       	clr	r8		
    caf8:	3d b0 00 80 	bit	#-32768,r13	;#0x8000
    cafc:	05 24       	jz	$+12     	;abs 0xcb08
    cafe:	3d e3       	inv	r13		
    cb00:	3c e3       	inv	r12		
    cb02:	1c 53       	inc	r12		
    cb04:	0d 63       	adc	r13		
    cb06:	28 d2       	bis	#4,	r8	;r2 As==10
    cb08:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    cb0c:	05 24       	jz	$+12     	;abs 0xcb18
    cb0e:	3b e3       	inv	r11		
    cb10:	3a e3       	inv	r10		
    cb12:	1a 53       	inc	r10		
    cb14:	0b 63       	adc	r11		
    cb16:	38 d2       	bis	#8,	r8	;r2 As==11
    cb18:	b0 12 40 cb 	call	#0xcb40	
    cb1c:	08 10       	rrc	r8		
    cb1e:	28 b2       	bit	#4,	r8	;r2 As==10
    cb20:	08 24       	jz	$+18     	;abs 0xcb32
    cb22:	3e e3       	inv	r14		
    cb24:	3f e3       	inv	r15		
    cb26:	1e 53       	inc	r14		
    cb28:	0f 63       	adc	r15		
    cb2a:	3c e3       	inv	r12		
    cb2c:	3d e3       	inv	r13		
    cb2e:	1c 53       	inc	r12		
    cb30:	0d 63       	adc	r13		
    cb32:	38 b2       	bit	#8,	r8	;r2 As==11
    cb34:	04 24       	jz	$+10     	;abs 0xcb3e
    cb36:	3c e3       	inv	r12		
    cb38:	3d e3       	inv	r13		
    cb3a:	1c 53       	inc	r12		
    cb3c:	0d 63       	adc	r13		
    cb3e:	30 41       	ret			

0000cb40 <__udivmodsi4>:
    cb40:	0f ef       	xor	r15,	r15	
    cb42:	0e ee       	xor	r14,	r14	
    cb44:	39 40 21 00 	mov	#33,	r9	;#0x0021
    cb48:	0a 3c       	jmp	$+22     	;abs 0xcb5e
    cb4a:	08 10       	rrc	r8		
    cb4c:	0e 6e       	rlc	r14		
    cb4e:	0f 6f       	rlc	r15		
    cb50:	0f 9b       	cmp	r11,	r15	
    cb52:	05 28       	jnc	$+12     	;abs 0xcb5e
    cb54:	02 20       	jnz	$+6      	;abs 0xcb5a
    cb56:	0e 9a       	cmp	r10,	r14	
    cb58:	02 28       	jnc	$+6      	;abs 0xcb5e
    cb5a:	0e 8a       	sub	r10,	r14	
    cb5c:	0f 7b       	subc	r11,	r15	
    cb5e:	0c 6c       	rlc	r12		
    cb60:	0d 6d       	rlc	r13		
    cb62:	08 68       	rlc	r8		
    cb64:	19 83       	dec	r9		
    cb66:	f1 23       	jnz	$-28     	;abs 0xcb4a
    cb68:	30 41       	ret			

0000cb6a <_unexpected_>:
    cb6a:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	5c c0 5c c0 5c c0 5c c0 5c c0 5c c0 12 c1 e8 c0     \.\.\.\.\.\.....
    fff0:	5c c0 5c c0 5c c0 5c c0 5c c0 5c c0 5c c0 00 c0     \.\.\.\.\.\.\...
